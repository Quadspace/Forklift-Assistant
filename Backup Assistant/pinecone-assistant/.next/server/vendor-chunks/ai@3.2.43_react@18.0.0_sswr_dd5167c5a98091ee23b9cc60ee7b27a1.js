"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1";
exports.ids = ["vendor-chunks/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/.pnpm/jsondiffpatch@0.6.0/node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\n\n\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMy4yLjQzX3JlYWN0QDE4LjAuMF9zc3dyX2RkNTE2N2M1YTk4MDkxZWUyM2I5Y2M2MGVlN2IyN2ExL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2hhcmVkLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkQ7O0FDQXBELElBQU1HLHdCQUF3QkMsT0FBT0MsR0FBQSxDQUFJO0FBQ3pDLElBQU1DLHNDQUFzQyxLQUFLOztBREd4RCxTQUFTQywwQkFBMEJDLEtBQUE7SUFDakMsT0FBTyxDQUFDLENBQ05BLENBQUFBLFNBQ0EsT0FBT0EsVUFBVSxZQUNqQixVQUFVQSxTQUNWQSxNQUFNQyxJQUFBLEtBQVNOLHFCQUFBO0FBRW5CO0FBRUEsU0FBU08sc0JBQ1BGLEtBQUE7SUFFQSxJQUFJLENBQUNELDBCQUEwQkMsUUFBUTtRQUNyQyxNQUFNLElBQUlHLE1BQ1I7SUFFSjtBQUNGO0FBRUEsU0FBU0Msa0JBQWtCSixLQUFBO0lBQ3pCLE1BQU1LLGVBQWVOLDBCQUEwQkM7SUFFL0MsSUFBSSxDQUFDSyxnQkFBZ0IsT0FBT0wsVUFBVSxhQUFhO1FBQ2pELE1BQU0sSUFBSUcsTUFDUjtJQUVKO0lBRUEsT0FBT0U7QUFDVDtBQWdDTyxTQUFTQyxvQkFDZEMsZUFBQTtJQUVBTCxzQkFBc0JLO0lBRXRCLE9BQU87UUFDTCxDQUFDWCxPQUFPWSxhQUFhO1lBQ25CLElBQUlDLE1BQ0ZGO1lBQ0YsSUFBSUcsT0FBT0QsSUFBSUMsSUFBQTtZQUNmLElBQUlDLE9BQU87WUFDWCxJQUFJQyxVQUFVO1lBRWQsT0FBTztnQkFDTCxNQUFNQztvQkFDSixJQUFJRixNQUFNLE9BQU87d0JBQUVYLE9BQU9VO3dCQUFNQyxNQUFNO29CQUFLO29CQUUzQ0YsTUFBTSxNQUFNQTtvQkFFWixJQUFJLE9BQU9BLElBQUlLLEtBQUEsS0FBVSxhQUFhO3dCQUNwQyxNQUFNTCxJQUFJSyxLQUFBO29CQUNaO29CQUNBLElBQUks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Q3BELE1BQU0sSUFBSTdFLE1BQ1I7SUFFSjtJQUVBLE1BQU1rRSxNQUFNRSxJQUFBLENBQUssRUFBQztJQUNsQixNQUFNZSxTQUFlOUMsOENBQUEsQ0FDbkIsT0FBTzZCLFFBQVEsY0FDWFcsS0FBQSxDQUFNLEVBQUMsR0FDUCxDQUFDUTtRQUNDLElBQUluRCxXQUFXbUQsV0FBVztZQUN4QixPQUFPUixLQUFBLENBQU0sRUFBQyxDQUFFLENBQUFTO2dCQUNkLE9BQU87b0JBQUUsR0FBR0EsQ0FBQTtvQkFBRyxDQUFDcEIsSUFBRyxFQUFHbUIsU0FBU0MsQ0FBQSxDQUFFcEIsSUFBSTtnQkFBRTtZQUN6QztRQUNGLE9BQU87WUFDTCxPQUFPVyxLQUFBLENBQU0sRUFBQyxDQUFFO2dCQUFFLEdBQUdBLEtBQUEsQ0FBTSxFQUFDO2dCQUFHLENBQUNYLElBQUcsRUFBR21CO1lBQVM7UUFDakQ7SUFDRixHQUNKO1FBQUNuQjtLQUFHO0lBR04sSUFBSUUsS0FBS2MsTUFBQSxLQUFXLEdBQUc7UUFDckIsT0FBT0w7SUFDVCxPQUFPO1FBQ0wsT0FBTztZQUFDQSxLQUFBLENBQU0sRUFBQyxDQUFFVCxJQUFBLENBQUssRUFBRTtZQUFHZTtTQUFNO0lBQ25DO0FBQ0Y7QUFFTyxTQUFTSTtJQUdkLE1BQU1DLFVBQWdCbkQsNkNBQUEsQ0FBY0c7SUFDcEMsT0FBT2dEO0FBQ1Q7QUFFTyxTQUFTQztJQUNkLE1BQU1DLGNBQW9CckQsNkNBQUEsQ0FDeEJJO0lBR0YsSUFBSWlELGdCQUFnQixNQUFNO1FBQ3hCLE1BQU0sSUFBSTFGLE1BQU07SUFDbEI7SUFFQSxPQUFPMEY7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL1BpbmVjb25lIEFzc2lzdGFudCBTYW1wbGUgQXBwLy4uL3NoYXJlZC1jbGllbnQvc3RyZWFtYWJsZS50c3g/ZTE4YiIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi9jb25zdGFudHMudHM/YWI3MiIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi9zaGFyZWQtY2xpZW50L2NvbnRleHQudHN4P2NiM2YiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vdXRpbHMudHN4PzdhMmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU1RSRUFNQUJMRV9WQUxVRV9UWVBFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5mdW5jdGlvbiBoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgcmV0dXJuICEhKFxuICAgIHZhbHVlICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICd0eXBlJyBpbiB2YWx1ZSAmJlxuICAgIHZhbHVlLnR5cGUgPT09IFNUUkVBTUFCTEVfVkFMVUVfVFlQRVxuICApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJlYW1hYmxlVmFsdWUoXG4gIHZhbHVlOiB1bmtub3duLFxuKTogYXNzZXJ0cyB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICBpZiAoIWhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIGNvbnN0IGhhc1NpZ25hdHVyZSA9IGhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpO1xuXG4gIGlmICghaGFzU2lnbmF0dXJlICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGhhc1NpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbnNpZGUgeW91ciBBSSBhY3Rpb246XG4gKlxuICogYXN5bmMgZnVuY3Rpb24gYWN0aW9uKCkge1xuICogICAndXNlIHNlcnZlcidcbiAqICAgY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpO1xuICpcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMSk7XG4gKiAgIHN0cmVhbWFibGUudXBkYXRlKDIpO1xuICogICBzdHJlYW1hYmxlLmRvbmUoMyk7XG4gKiAgIC8vIC4uLlxuICogICByZXR1cm4gc3RyZWFtYWJsZS52YWx1ZTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEFuZCB0byByZWFkIHRoZSB2YWx1ZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gYXdhaXQgYWN0aW9uKClcbiAqIGZvciBhd2FpdCAoY29uc3QgdiBvZiByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHtcbiAqICAgY29uc29sZS5sb2codilcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgbG9ncyBvdXQgMSwgMiwgMyBvbiBjb25zb2xlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZTogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogQXN5bmNJdGVyYWJsZTxUIHwgdW5kZWZpbmVkPiB7XG4gIGFzc2VydFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIGxldCByb3c6IFN0cmVhbWFibGVWYWx1ZTxUPiB8IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQ+PiA9XG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZTtcbiAgICAgIGxldCBjdXJyID0gcm93LmN1cnI7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IGluaXRpYWwgPSB0cnVlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm4geyB2YWx1ZTogY3VyciwgZG9uZTogdHJ1ZSB9O1xuXG4gICAgICAgICAgcm93ID0gYXdhaXQgcm93O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiByb3cuZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnY3VycicgaW4gcm93IHx8IHJvdy5kaWZmKSB7XG4gICAgICAgICAgICBpZiAocm93LmRpZmYpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChyb3cuZGlmZlswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIHBhdGNoOiBjYW4gb25seSBhcHBlbmQgdG8gc3RyaW5nIHR5cGVzLiBUaGlzIGlzIGEgYnVnIGluIHRoZSBBSSBTREsuJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChjdXJyIGFzIHN0cmluZykgPSBjdXJyICsgcm93LmRpZmZbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyciA9IHJvdy5jdXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBlbWl0dGVkIHsgZG9uZTogdHJ1ZSB9IHdvbid0IGJlIHVzZWQgYXMgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBieSB0aGUgZm9yIGF3YWl0Li4ub2Ygc3ludGF4LlxuICAgICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VycixcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJvdy5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogY3VycixcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ID0gcm93Lm5leHQ7XG4gICAgICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCBjaHVuayBhbmQgdGhlcmUgaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZSB5ZXQuXG4gICAgICAgICAgICAgIC8vIExldCdzIHNraXAgdGhpcyBvbmUuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIGB1c2VTdHJlYW1hYmxlVmFsdWVgIGlzIGEgUmVhY3QgaG9vayB0aGF0IHRha2VzIGEgc3RyZWFtYWJsZSB2YWx1ZSBjcmVhdGVkIHZpYSB0aGUgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpLnZhbHVlYCBBUEksXG4gKiBhbmQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSwgZXJyb3IsIGFuZCBwZW5kaW5nIHN0YXRlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb25zdW1pbmcgc3RyZWFtYWJsZSB2YWx1ZXMgcmVjZWl2ZWQgZnJvbSBhIGNvbXBvbmVudCdzIHByb3BzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gTXlDb21wb25lbnQoeyBzdHJlYW1hYmxlVmFsdWUgfSkge1xuICogICBjb25zdCBbZGF0YSwgZXJyb3IsIHBlbmRpbmddID0gdXNlU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gKlxuICogICBpZiAocGVuZGluZykgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcbiAqICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5FcnJvcjoge2Vycm9yLm1lc3NhZ2V9PC9kaXY+O1xuICpcbiAqICAgcmV0dXJuIDxkaXY+RGF0YToge2RhdGF9PC9kaXY+O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHJlYW1hYmxlVmFsdWU8VCA9IHVua25vd24sIEVycm9yID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZT86IFN0cmVhbWFibGVWYWx1ZTxUPixcbik6IFtkYXRhOiBUIHwgdW5kZWZpbmVkLCBlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQsIHBlbmRpbmc6IGJvb2xlYW5dIHtcbiAgY29uc3QgW2N1cnIsIHNldEN1cnJdID0gdXNlU3RhdGU8VCB8IHVuZGVmaW5lZD4oXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5jdXJyIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgdW5kZWZpbmVkPihcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmVycm9yIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gISFzdHJlYW1hYmxlVmFsdWUubmV4dCA6IGZhbHNlLFxuICApO1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSByZXR1cm47XG5cbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAgICBpZiAoc3RyZWFtYWJsZVZhbHVlLm5leHQpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRDdXJyKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldEVycm9yKGUgYXMgRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbc3RyZWFtYWJsZVZhbHVlXSk7XG5cbiAgcmV0dXJuIFtjdXJyLCBlcnJvciwgcGVuZGluZ107XG59XG4iLCJleHBvcnQgY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcigndWkuc3RyZWFtYWJsZS52YWx1ZScpO1xuZXhwb3J0IGNvbnN0IERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FID0gMTUgKiAxMDAwO1xuIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMganNvbmRpZmZwYXRjaCBmcm9tICdqc29uZGlmZnBhdGNoJztcbmltcG9ydCB0eXBlIHtcbiAgSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMsXG4gIEFJUHJvdmlkZXIsXG4gIEluZmVyQUlTdGF0ZSxcbiAgVmFsdWVPclVwZGF0ZXIsXG4gIEluZmVyQWN0aW9ucyxcbiAgSW5mZXJVSVN0YXRlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBJbnRlcm5hbFVJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5jb25zdCBJbnRlcm5hbEFJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5kZWZpbmVkIHwgYW55Pih1bmRlZmluZWQpO1xuY29uc3QgSW50ZXJuYWxBY3Rpb25Qcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5jb25zdCBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gSW50ZXJuYWxBSVByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxVSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgd3JhcHBlZEFjdGlvbnMsXG4gIHdyYXBwZWRTeW5jVUlTdGF0ZSxcbn06IEludGVybmFsQUlQcm92aWRlclByb3BzKSB7XG4gIGlmICghKCd1c2UnIGluIFJlYWN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUmVhY3QgdmVyc2lvbi4nKTtcbiAgfVxuXG4gIGNvbnN0IHVpU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVUlTdGF0ZSk7XG4gIGNvbnN0IHNldFVJU3RhdGUgPSB1aVN0YXRlWzFdO1xuXG4gIGNvbnN0IHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCA9IGluaXRpYWxBSVN0YXRlUGF0Y2hcbiAgICA/IChSZWFjdCBhcyBhbnkpLnVzZShpbml0aWFsQUlTdGF0ZVBhdGNoKVxuICAgIDogdW5kZWZpbmVkO1xuICBpbml0aWFsQUlTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gpIHtcbiAgICAgIHJldHVybiBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGluaXRpYWxBSVN0YXRlKSxcbiAgICAgICAgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxBSVN0YXRlO1xuICB9LCBbaW5pdGlhbEFJU3RhdGUsIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaF0pO1xuXG4gIGNvbnN0IGFpU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsQUlTdGF0ZSk7XG4gIGNvbnN0IHNldEFJU3RhdGUgPSBhaVN0YXRlWzFdO1xuICBjb25zdCBhaVN0YXRlUmVmID0gUmVhY3QudXNlUmVmKGFpU3RhdGVbMF0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWlTdGF0ZVJlZi5jdXJyZW50ID0gYWlTdGF0ZVswXTtcbiAgfSwgW2FpU3RhdGVbMF1dKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkQWN0aW9ucyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMod3JhcHBlZEFjdGlvbnMpLm1hcCgoW2tleSwgYWN0aW9uXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhc3luYyAoLi4uYXJnczogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCByZXN1bHRdID0gYXdhaXQgYWN0aW9uKFxuICAgICAgICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICAgICAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWlTdGF0ZVsxXShcbiAgICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sXG4gICAgICAgIF0pLFxuICAgICAgKSxcbiAgICBbd3JhcHBlZEFjdGlvbnNdLFxuICApO1xuXG4gIGNvbnN0IGNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghd3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHVpU3RhdGVdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlIShcbiAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgKTtcblxuICAgICAgaWYgKHVpU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRVSVN0YXRlKHVpU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRBaVN0YXRlID0ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICk7XG4gICAgICAgIHNldEFJU3RhdGUocGF0Y2hlZEFpU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt3cmFwcGVkU3luY1VJU3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17YWlTdGF0ZX0+XG4gICAgICA8SW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e3VpU3RhdGV9PlxuICAgICAgICA8SW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlciB2YWx1ZT17Y2xpZW50V3JhcHBlZEFjdGlvbnN9PlxuICAgICAgICAgIDxJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXJcbiAgICAgICAgICAgIHZhbHVlPXtjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb259XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgICA8L0ludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICA8L0ludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgIDwvSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyVUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsICh2OiBUIHwgKCh2XzogVCkgPT4gVCkpID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsVUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbFVJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vLyBUT0RPOiBIb3cgZG8gd2UgYXZvaWQgY2F1c2luZyBhIHJlLXJlbmRlciB3aGVuIHRoZSBBSSBzdGF0ZSBjaGFuZ2VzIGJ1dCB5b3Vcbi8vIGFyZSBvbmx5IGxpc3RlbmluZyB0byBhIHNwZWNpZmljIGtleT8gV2UgbmVlZCB1c2VTRVMgcGVyaGFwcz9cbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PixcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT4+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XSxcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgVCA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsQUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlQUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbEFJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEgJiYgdHlwZW9mIHN0YXRlWzBdICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdXaGVuIHVzaW5nIGB1c2VBSVN0YXRlYCB3aXRoIGEga2V5LCB0aGUgQUkgc3RhdGUgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgY29uc3Qgc2V0dGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gc3RhdGVbMV1cbiAgICAgIDogKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4ge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHMgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5zLCBba2V5XTogbmV3U3RhdGUoc1trZXldKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXSh7IC4uLnN0YXRlWzBdLCBba2V5XTogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFtrZXldLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3N0YXRlWzBdW2FyZ3NbMF1dLCBzZXR0ZXJdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3Rpb25zPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyQWN0aW9uczxBSSwgYW55PjtcblxuICBjb25zdCBhY3Rpb25zID0gUmVhY3QudXNlQ29udGV4dDxUPihJbnRlcm5hbEFjdGlvblByb3ZpZGVyKTtcbiAgcmV0dXJuIGFjdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTeW5jVUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3luY1VJU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PCgpID0+IFByb21pc2U8dm9pZD4+KFxuICAgIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlcixcbiAgKTtcblxuICBpZiAoc3luY1VJU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VTeW5jVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIHN5bmNVSVN0YXRlO1xufVxuXG5leHBvcnQgeyB1c2VBSVN0YXRlIH07XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxUID0gYW55PigpIHtcbiAgbGV0IHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZCwgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG5cbi8vIFVzZSB0aGUgbmFtZSBgUmAgZm9yIGBSb3dgIGFzIGl0IHdpbGwgYmUgc2hvcnRlciBpbiB0aGUgUlNDIHBheWxvYWQuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjLCAvLyBjdXJyZW50XG4gICAgbiwgLy8gbmV4dFxuICB9OiB7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgbjtcbiAgICBpZiAoY2h1bmsuZG9uZSkge1xuICAgICAgcmV0dXJuIGNodW5rLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChjaHVuay5hcHBlbmQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2N9XG4gICAgICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgICAgICA8L1N1c3BlbnNlPlxuICAgICAgICA8Lz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKTtcbiAgfSkgYXMgdW5rbm93biBhcyBSZWFjdC5GQzx7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfT4sXG5dWzBdO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICByb3c6IChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17aW5pdGlhbFZhbHVlfT5cbiAgICAgICAgPFIgYz17aW5pdGlhbFZhbHVlfSBuPXtwcm9taXNlfSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApIGFzIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAoeDogdW5rbm93bik6IHggaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBjb25zdW1lU3RyZWFtID0gYXN5bmMgKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pID0+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsic3RhcnRUcmFuc2l0aW9uIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlU3RhdGUiLCJTVFJFQU1BQkxFX1ZBTFVFX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSIsImhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUiLCJ2YWx1ZSIsInR5cGUiLCJhc3NlcnRTdHJlYW1hYmxlVmFsdWUiLCJFcnJvciIsImlzU3RyZWFtYWJsZVZhbHVlIiwiaGFzU2lnbmF0dXJlIiwicmVhZFN0cmVhbWFibGVWYWx1ZSIsInN0cmVhbWFibGVWYWx1ZSIsImFzeW5jSXRlcmF0b3IiLCJyb3ciLCJjdXJyIiwiZG9uZSIsImluaXRpYWwiLCJuZXh0IiwiZXJyb3IiLCJkaWZmIiwidXNlU3RyZWFtYWJsZVZhbHVlIiwic2V0Q3VyciIsInNldEVycm9yIiwicGVuZGluZyIsInNldFBlbmRpbmciLCJjYW5jZWxsZWQiLCJpdGVyYXRvciIsImUiLCJSZWFjdCIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsIlIiLCJjIiwibiIsImNodW5rIiwiYXBwZW5kIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsImlzRnVuY3Rpb24iLCJ4IiwiSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIiLCJSZWFjdDIiLCJjcmVhdGVDb250ZXh0IiwiSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFjdGlvblByb3ZpZGVyIiwiSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBSVByb3ZpZGVyIiwiaW5pdGlhbFVJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giLCJ3cmFwcGVkQWN0aW9ucyIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsInVpU3RhdGUiLCJzZXRVSVN0YXRlIiwicmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoIiwidXNlIiwidXNlTWVtbyIsInBhdGNoIiwiY2xvbmUiLCJhaVN0YXRlIiwic2V0QUlTdGF0ZSIsImFpU3RhdGVSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiY2xpZW50V3JhcHBlZEFjdGlvbnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJrZXkiLCJhY3Rpb24iLCJhcmdzIiwiYWlTdGF0ZVNuYXBzaG90IiwiYWlTdGF0ZURlbHRhIiwicmVzdWx0IiwiZGVsdGEiLCJjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24iLCJwYXRjaGVkQWlTdGF0ZSIsIlByb3ZpZGVyIiwidXNlVUlTdGF0ZSIsInN0YXRlIiwidXNlQ29udGV4dCIsIkFycmF5IiwiaXNBcnJheSIsInVzZUFJU3RhdGUiLCJsZW5ndGgiLCJzZXR0ZXIiLCJ1c2VDYWxsYmFjayIsIm5ld1N0YXRlIiwicyIsInVzZUFjdGlvbnMiLCJhY3Rpb25zIiwidXNlU3luY1VJU3RhdGUiLCJzeW5jVUlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(action-browser)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(action-browser)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jsondiffpatch */ \"(action-browser)/./node_modules/.pnpm/jsondiffpatch@0.6.0/node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(action-browser)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(action-browser)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/.pnpm/zod-to-json-schema@3.22.5_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider */ \"(action-browser)/./node_modules/.pnpm/@ai-sdk+provider@0.0.14/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(action-browser)/./node_modules/.pnpm/@ai-sdk+provider-utils@1.0.5_zod@3.23.8/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(action-browser)/./node_modules/.pnpm/eventsource-parser@1.1.2/node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(action-browser)/./node_modules/.pnpm/@ai-sdk+ui-utils@0.0.23_zod@3.23.8/node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(action-browser)/./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"71021c714e64cac170c025f22847ac065d691340\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\n\n\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspensedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/util/download.ts\n\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a = response.headers.get(\"content-type\")) != null ? _a : void 0\n        };\n    } catch (error) {\n        if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.DownloadError.isDownloadError(error)) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/invalid-message-role-error.ts\nvar InvalidMessageRoleError = class extends Error {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super(message);\n        this.name = \"AI_InvalidMessageRoleError\";\n        this.role = role;\n    }\n    static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === \"AI_InvalidMessageRoleError\" && typeof error.role === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, downloadImplementation = download }) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    const downloadedImages = modelSupportsImageUrls || prompt.messages == null ? null : await downloadImages(prompt.messages, downloadImplementation);\n    const promptType = prompt.type;\n    switch(promptType){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedImages)));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = promptType;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message, downloadedImages) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ]\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>{\n                        var _a, _b, _c;\n                        switch(part.type){\n                            case \"text\":\n                                {\n                                    return part;\n                                }\n                            case \"image\":\n                                {\n                                    if (part.image instanceof URL) {\n                                        if (downloadedImages == null) {\n                                            return {\n                                                type: \"image\",\n                                                image: part.image,\n                                                mimeType: part.mimeType\n                                            };\n                                        } else {\n                                            const downloadedImage = downloadedImages[part.image.toString()];\n                                            return {\n                                                type: \"image\",\n                                                image: downloadedImage.data,\n                                                mimeType: (_a = part.mimeType) != null ? _a : downloadedImage.mimeType\n                                            };\n                                        }\n                                    }\n                                    if (typeof part.image === \"string\") {\n                                        try {\n                                            const url = new URL(part.image);\n                                            switch(url.protocol){\n                                                case \"http:\":\n                                                case \"https:\":\n                                                    {\n                                                        if (downloadedImages == null) {\n                                                            return {\n                                                                type: \"image\",\n                                                                image: url,\n                                                                mimeType: part.mimeType\n                                                            };\n                                                        } else {\n                                                            const downloadedImage = downloadedImages[part.image];\n                                                            return {\n                                                                type: \"image\",\n                                                                image: downloadedImage.data,\n                                                                mimeType: (_b = part.mimeType) != null ? _b : downloadedImage.mimeType\n                                                            };\n                                                        }\n                                                    }\n                                                case \"data:\":\n                                                    {\n                                                        try {\n                                                            const [header, base64Content] = part.image.split(\",\");\n                                                            const mimeType = header.split(\";\")[0].split(\":\")[1];\n                                                            if (mimeType == null || base64Content == null) {\n                                                                throw new Error(\"Invalid data URL format\");\n                                                            }\n                                                            return {\n                                                                type: \"image\",\n                                                                image: convertDataContentToUint8Array(base64Content),\n                                                                mimeType\n                                                            };\n                                                        } catch (error) {\n                                                            throw new Error(`Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(message)}`);\n                                                        }\n                                                    }\n                                                default:\n                                                    {\n                                                        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                                                    }\n                                            }\n                                        } catch (_ignored) {}\n                                    }\n                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                    return {\n                                        type: \"image\",\n                                        image: imageUint8,\n                                        mimeType: (_c = part.mimeType) != null ? _c : detectImageMimeType(imageUint8)\n                                    };\n                                }\n                        }\n                    })\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ]\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\")\n                };\n            }\n        case \"tool\":\n            {\n                return message;\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadImages(messages, downloadImplementation) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\").map((part)=>part.image).map((part)=>// support string urls in image parts:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL);\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.messages != null) {\n        for (const message of prompt.messages){\n            if (message.role === \"system\" && typeof message.content !== \"string\") {\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n                    prompt,\n                    message: \"system message content must be a string\"\n                });\n            }\n        }\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/types/token-usage.ts\nfunction calculateCompletionTokenUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// core/util/schema.ts\n\n\nvar schemaSymbol = Symbol(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, { validate } = {}) {\n    return {\n        [schemaSymbol]: true,\n        _type: void 0,\n        // should never be used directly\n        [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.validatorSymbol]: true,\n        jsonSchema: jsonSchema2,\n        validate\n    };\n}\nfunction isSchema(value) {\n    return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n    return isSchema(schema) ? schema : zodSchema(schema);\n}\nfunction zodSchema(zodSchema2) {\n    return jsonSchema(// we assume that zodToJsonSchema will return a valid JSONSchema7:\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema2), {\n        validate: (value)=>{\n            const result = zodSchema2.safeParse(value);\n            return result.success ? {\n                success: true,\n                value: result.data\n            } : {\n                success: false,\n                error: result.error\n            };\n        }\n    });\n}\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    return {\n        tools: Object.entries(tools).map(([name, tool])=>({\n                type: \"function\",\n                name,\n                description: tool.description,\n                parameters: asSchema(tool.parameters).jsonSchema\n            })),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspensedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        value: row,\n        update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable2;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable2;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, initial, text, onFinish, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res, lastCall = false) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            if (lastCall) {\n                res.done(node);\n            } else {\n                res.update(node);\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                if (lastCall && done) {\n                    res.done(value2);\n                } else {\n                    res.update(value2);\n                }\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                if (lastCall && done) {\n                    res.done(value2);\n                } else {\n                    res.update(value2);\n                }\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            if (lastCall) {\n                res.done(value);\n            } else {\n                res.update(value);\n            }\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(async ()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice\n                })\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n                prompt: validatedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls\n            }),\n            abortSignal,\n            headers\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui, true);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {\n                            onFinish == null ? void 0 : onFinish({\n                                finishReason: value.finishReason,\n                                usage: calculateCompletionTokenUsage(value.usage),\n                                value: ui.value,\n                                warnings: result.warnings,\n                                rawResponse: result.rawResponse\n                            });\n                        }\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui, true);\n                await finished;\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"71021c714e64cac170c025f22847ac065d691340\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_3__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_11__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9haUAzLjIuNDNfcmVhY3RAMTguMC4wX3Nzd3JfZGQ1MTY3YzVhOTgwOTFlZTIzYjljYzYwZWU3YjI3YTEvbm9kZV9tb2R1bGVzL2FpL3JzYy9kaXN0L3JzYy1zZXJ2ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNIOztBQ0RDO0FBK0J4QjtBQTdCRCxTQUFTTTtJQUNkLElBQUlDLFNBQTZCQztJQUNqQyxNQUFNQyxVQUFVLElBQUlDLFFBQVcsQ0FBQ0MsS0FBS0M7UUFDbkNMLFVBQVVJO1FBQ1ZILFNBQVNJO0lBQ1g7SUFDQSxPQUFPO1FBQ0xIO1FBQ0FGO1FBQ0FDO0lBQ0Y7QUFDRjtBQUdBLElBQU1LLElBQUk7SUFDUCxPQUFPLEVBQ05DLENBQUE7SUFDQUMsQ0FBQSxFQUNGO1FBSUUsTUFBTUMsUUFBUSxNQUFNRDtRQUNwQixJQUFJQyxNQUFNQyxJQUFBLEVBQU07WUFDZCxPQUFPRCxNQUFNRSxLQUFBO1FBQ2Y7UUFFQSxJQUFJRixNQUFNRyxNQUFBLEVBQVE7WUFDaEIsT0FDRSxnQkFBQWQsdURBQUFBLENBQUFGLHVEQUFBQSxFQUFBO2dCQUNHaUIsVUFBQTtvQkFBQU47b0JBQ0QsZ0JBQUFWLHNEQUFBQSxDQUFDRiwyQ0FBUUEsRUFBUjt3QkFBU21CLFVBQVVMLE1BQU1FLEtBQUE7d0JBQ3hCRSxVQUFBLGdCQUFBaEIsc0RBQUFBLENBQUNTLEdBQUE7NEJBQUVDLEdBQUdFLE1BQU1FLEtBQUE7NEJBQU9ILEdBQUdDLE1BQU1NLElBQUE7d0JBQUE7b0JBQU07aUJBQ3BDO1lBQUE7UUFHTjtRQUVBLE9BQ0UsZ0JBQUFsQixzREFBQUEsQ0FBQ0YsMkNBQVFBLEVBQVI7WUFBU21CLFVBQVVMLE1BQU1FLEtBQUE7WUFDeEJFLFVBQUEsZ0JBQUFoQixzREFBQUEsQ0FBQ1MsR0FBQTtnQkFBRUMsR0FBR0UsTUFBTUUsS0FBQTtnQkFBT0gsR0FB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O1FBQ3RDLElBQUlPLFVBQUEsQ0FBVTVXLEtBQUEwVyxNQUFNTixjQUFBLEtBQU4sT0FBQXBXLEtBQXdCb1c7UUFDdEMsSUFBSVMsZUFBZTtRQUVuQixJQUFJTCxvQkFBb0I7WUFDdEIsTUFBTSxDQUFDTSxpQkFBaUJDLFdBQVUsR0FBSSxNQUFNUCxtQkFBbUJJO1lBQy9ELElBQUlHLGVBQWUsUUFBVztnQkFDNUJGLGVBQWVDO2dCQUNmSCxVQUFVSTtZQUNaO1FBQ0Y7UUFFQSxPQUNFLGdCQUFBdmEsc0RBQUFBLENBQUNxWixnRUFBa0JBLEVBQWxCO1lBQ0NVO1lBQ0FDO1lBQ0FILGdCQUFnQk07WUFDaEJQLGdCQUFnQlE7WUFDaEJJLHFCQUFxQkg7WUFFcEJyWixVQUFBa1osTUFBTWxaLFFBQUE7UUFBQTtJQUdiO0lBRUEsT0FBT2laO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi9haS1zdGF0ZS50c3g/MzgwMCIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi91dGlscy50c3g/N2EyZSIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi9zdHJlYW1hYmxlLnRzeD82OTFmIiwid2VicGFjazovL1BpbmVjb25lIEFzc2lzdGFudCBTYW1wbGUgQXBwLy4uLy4uL2NvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHM/ZjBkMCIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9jb3JlL3V0aWwvZGVsYXkudHM/YTFlNyIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50cz83MTc0Iiwid2VicGFjazovL1BpbmVjb25lIEFzc2lzdGFudCBTYW1wbGUgQXBwLy4uLy4uL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHM/OTU0NSIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9jb3JlL3V0aWwvZG93bmxvYWQudHM/ZDkyYSIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9jb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHM/ZTkyZiIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9jb3JlL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50cz84OTcwIiwid2VicGFjazovL1BpbmVjb25lIEFzc2lzdGFudCBTYW1wbGUgQXBwLy4uLy4uL2NvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzPzU3OGUiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzP2Q1OGMiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vLi4vY29yZS90eXBlcy90b2tlbi11c2FnZS50cz85YWY0Iiwid2VicGFjazovL1BpbmVjb25lIEFzc2lzdGFudCBTYW1wbGUgQXBwLy4uLy4uL2NvcmUvdXRpbC9zY2hlbWEudHM/Mzc3ZCIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9jb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50cz9jYWM4Iiwid2VicGFjazovL1BpbmVjb25lIEFzc2lzdGFudCBTYW1wbGUgQXBwLy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzPzE4YTAiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vLi4vc3RyZWFtcy9haS1zdHJlYW0udHM/NDg1NCIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi8uLi9zdHJlYW1zL3N0cmVhbS1kYXRhLnRzPzY3MzAiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vLi4vc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzP2IyYmQiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vY29uc3RhbnRzLnRzP2FiNzIiLCJ3ZWJwYWNrOi8vUGluZWNvbmUgQXNzaXN0YW50IFNhbXBsZSBBcHAvLi4vc3RyZWFtLXVpL3N0cmVhbS11aS50c3g/MWNjYSIsIndlYnBhY2s6Ly9QaW5lY29uZSBBc3Npc3RhbnQgU2FtcGxlIEFwcC8uLi9wcm92aWRlci50c3g/MzBlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ2FzeW5jX2hvb2tzJztcbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSwgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUge1xuICBBSVByb3ZpZGVyLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgSW5mZXJBSVN0YXRlLFxuICBNdXRhYmxlQUlTdGF0ZSxcbiAgVmFsdWVPclVwZGF0ZXIsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBJdCBpcyBwb3NzaWJsZSB0aGF0IG11bHRpcGxlIEFJIHJlcXVlc3RzIGdldCBpbiBjb25jdXJyZW50bHksIGZvciBkaWZmZXJlbnRcbi8vIEFJIGluc3RhbmNlcy4gU28gQUxTIGlzIG5lY2Vzc2FyeSBoZXJlIGZvciBhIHNpbXBsZXIgQVBJLlxuY29uc3QgYXN5bmNBSVN0YXRlU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTx7XG4gIGN1cnJlbnRTdGF0ZTogYW55O1xuICBvcmlnaW5hbFN0YXRlOiBhbnk7XG4gIHNlYWxlZDogYm9vbGVhbjtcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnM7XG4gIG11dGF0aW9uRGVsdGFQcm9taXNlPzogUHJvbWlzZTxhbnk+O1xuICBtdXRhdGlvbkRlbHRhUmVzb2x2ZT86ICh2OiBhbnkpID0+IHZvaWQ7XG59PigpO1xuXG5mdW5jdGlvbiBnZXRBSVN0YXRlU3RvcmVPclRocm93KG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCBzdG9yZSA9IGFzeW5jQUlTdGF0ZVN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQUlTdGF0ZTxTLCBUPihcbiAgeyBzdGF0ZSwgb3B0aW9ucyB9OiB7IHN0YXRlOiBTOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBmbjogKCkgPT4gVCxcbik6IFQge1xuICByZXR1cm4gYXN5bmNBSVN0YXRlU3RvcmFnZS5ydW4oXG4gICAge1xuICAgICAgY3VycmVudFN0YXRlOiBzdGF0ZSxcbiAgICAgIG9yaWdpbmFsU3RhdGU6IHN0YXRlLFxuICAgICAgc2VhbGVkOiBmYWxzZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgfSxcbiAgICBmbixcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFJU3RhdGVEZWx0YVByb21pc2UoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdygnSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuJyk7XG4gIHJldHVybiBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZTtcbn1cblxuLy8gSW50ZXJuYWwgbWV0aG9kLiBUaGlzIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBBSSBBY3Rpb24gaGFzIGJlZW4gcmV0dXJuZWRcbi8vIGFuZCB5b3UgY2FuIG5vIGxvbmdlciBjYWxsIGBnZXRNdXRhYmxlQUlTdGF0ZSgpYCBpbnNpZGUgYW55IGFzeW5jIGNhbGxiYWNrc1xuLy8gY3JlYXRlZCBieSB0aGF0IEFjdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBzZWFsTXV0YWJsZUFJU3RhdGUoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdygnSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuJyk7XG4gIHN0b3JlLnNlYWxlZCA9IHRydWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IEFJIHN0YXRlLlxuICogSWYgYGtleWAgaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGtleSBpbiB0aGVcbiAqIEFJIHN0YXRlLCBpZiBpdCdzIGFuIG9iamVjdC4gSWYgaXQncyBub3QgYW4gb2JqZWN0LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICpcbiAqIEBleGFtcGxlIGNvbnN0IHN0YXRlID0gZ2V0QUlTdGF0ZSgpIC8vIEdldCB0aGUgZW50aXJlIEFJIHN0YXRlXG4gKiBAZXhhbXBsZSBjb25zdCBmaWVsZCA9IGdldEFJU3RhdGUoJ2tleScpIC8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleVxuICovXG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogUmVhZG9ubHk8XG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PlxuPjtcbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBSZWFkb25seTxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+O1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgJ2BnZXRBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXkgYXMga2V5b2YgdHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZV07XG4gIH1cblxuICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbXV0YWJsZSBBSSBzdGF0ZS4gTm90ZSB0aGF0IHlvdSBtdXN0IGNhbGwgYC5kb25lKClgIHdoZW4gZmluaXNoaW5nXG4gKiB1cGRhdGluZyB0aGUgQUkgc3RhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS51cGRhdGUoeyAuLi5zdGF0ZS5nZXQoKSwga2V5OiAndmFsdWUnIH0pXG4gKiBzdGF0ZS51cGRhdGUoKGN1cnJlbnRTdGF0ZSkgPT4gKHsgLi4uY3VycmVudFN0YXRlLCBrZXk6ICd2YWx1ZScgfSkpXG4gKiBzdGF0ZS5kb25lKClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICogc3RhdGUuZG9uZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSkgLy8gRG9uZSB3aXRoIGEgbmV3IHN0YXRlXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBNdXRhYmxlQUlTdGF0ZTxcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XG4+O1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBNdXRhYmxlQUlTdGF0ZTxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+O1xuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgdHlwZSBBSVN0YXRlID0gSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuICB0eXBlIEFJU3RhdGVXaXRoS2V5ID0gdHlwZW9mIGFyZ3MgZXh0ZW5kcyBba2V5OiBrZXlvZiBBSVN0YXRlXVxuICAgID8gQUlTdGF0ZVsodHlwZW9mIGFyZ3MpWzBdXVxuICAgIDogQUlTdGF0ZTtcbiAgdHlwZSBOZXdTdGF0ZU9yVXBkYXRlciA9IFZhbHVlT3JVcGRhdGVyPEFJU3RhdGVXaXRoS2V5PjtcblxuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgJ2BnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi4nLFxuICApO1xuXG4gIGlmIChzdG9yZS5zZWFsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHJldHVybmluZyBmcm9tIGFuIEFJIEFjdGlvbi4gUGxlYXNlIG1vdmUgaXQgdG8gdGhlIHRvcCBsZXZlbCBvZiB0aGUgQWN0aW9uJ3MgZnVuY3Rpb24gYm9keS5cIixcbiAgICApO1xuICB9XG5cbiAgaWYgKCFzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZSkge1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZSA9IHByb21pc2U7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVJlc29sdmUgPSByZXNvbHZlO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9VcGRhdGUobmV3U3RhdGU6IE5ld1N0YXRlT3JVcGRhdGVyLCBkb25lOiBib29sZWFuKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGNhbid0IG1vZGlmeSB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICApfVwiIGZpZWxkIG9mIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0gPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGVbYXJnc1swXV0gPSBuZXdTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0b3JlLm9wdGlvbnMub25TZXRBSVN0YXRlPy4oe1xuICAgICAga2V5OiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogdW5kZWZpbmVkLFxuICAgICAgc3RhdGU6IHN0b3JlLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRvbmUsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBtdXRhYmxlU3RhdGUgPSB7XG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleV0gYXMgUmVhZG9ubHk8QUlTdGF0ZVdpdGhLZXk+O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlIGFzIFJlYWRvbmx5PEFJU3RhdGU+O1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobmV3QUlTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIpIHtcbiAgICAgIGRvVXBkYXRlKG5ld0FJU3RhdGUsIGZhbHNlKTtcbiAgICB9LFxuICAgIGRvbmU6IGZ1bmN0aW9uIGRvbmUoLi4uZG9uZUFyZ3M6IFtdIHwgW05ld1N0YXRlT3JVcGRhdGVyXSkge1xuICAgICAgaWYgKGRvbmVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZG9VcGRhdGUoZG9uZUFyZ3NbMF0gYXMgTmV3U3RhdGVPclVwZGF0ZXIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGpzb25kaWZmcGF0Y2guZGlmZihzdG9yZS5vcmlnaW5hbFN0YXRlLCBzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgc3RvcmUubXV0YXRpb25EZWx0YVJlc29sdmUhKGRlbHRhKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBtdXRhYmxlU3RhdGU7XG59XG5cbmV4cG9ydCB7IGdldEFJU3RhdGUsIGdldE11dGFibGVBSVN0YXRlIH07XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxUID0gYW55PigpIHtcbiAgbGV0IHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZCwgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG5cbi8vIFVzZSB0aGUgbmFtZSBgUmAgZm9yIGBSb3dgIGFzIGl0IHdpbGwgYmUgc2hvcnRlciBpbiB0aGUgUlNDIHBheWxvYWQuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjLCAvLyBjdXJyZW50XG4gICAgbiwgLy8gbmV4dFxuICB9OiB7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgbjtcbiAgICBpZiAoY2h1bmsuZG9uZSkge1xuICAgICAgcmV0dXJuIGNodW5rLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChjaHVuay5hcHBlbmQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2N9XG4gICAgICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgICAgICA8L1N1c3BlbnNlPlxuICAgICAgICA8Lz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKTtcbiAgfSkgYXMgdW5rbm93biBhcyBSZWFjdC5GQzx7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfT4sXG5dWzBdO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICByb3c6IChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17aW5pdGlhbFZhbHVlfT5cbiAgICAgICAgPFIgYz17aW5pdGlhbFZhbHVlfSBuPXtwcm9taXNlfSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApIGFzIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAoeDogdW5rbm93bik6IHggaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBjb25zdW1lU3RyZWFtID0gYXN5bmMgKHN0cmVhbTogUmVhZGFibGVTdHJlYW0pID0+IHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkgYnJlYWs7XG4gIH1cbn07XG4iLCJpbXBvcnQgdHlwZSB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gJ3pvZC10by1qc29uLXNjaGVtYSc7XG5cbi8vIFRPRE86IFRoaXMgbmVlZHMgdG8gYmUgZXh0ZXJuYWxpemVkLlxuaW1wb3J0IHsgT3BlbkFJU3RyZWFtIH0gZnJvbSAnLi4vc3RyZWFtcyc7XG5cbmltcG9ydCB7XG4gIFNUUkVBTUFCTEVfVkFMVUVfVFlQRSxcbiAgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlLFxuICBjcmVhdGVTdXNwZW5zZWRDaHVuayxcbiAgY29uc3VtZVN0cmVhbSxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFN0cmVhbWFibGVQYXRjaCwgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIEl0J3MgbmVjZXNzYXJ5IHRvIGRlZmluZSB0aGUgdHlwZSBtYW51YWxseSBoZXJlLCBvdGhlcndpc2UgVHlwZVNjcmlwdCBjb21waWxlclxuLy8gd2lsbCBub3QgYmUgYWJsZSB0byBpbmZlciB0aGUgY29ycmVjdCByZXR1cm4gdHlwZSBhcyBpdCdzIGNpcmN1bGFyLlxudHlwZSBTdHJlYW1hYmxlVUlXcmFwcGVyID0ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIFVJLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmQgcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC5cbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBSZWFjdC5SZWFjdE5vZGU7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgVUkgbm9kZS4gSXQgdGFrZXMgYSBuZXcgVUkgbm9kZSBhbmQgcmVwbGFjZXMgdGhlIG9sZCBvbmUuXG4gICAqL1xuICB1cGRhdGUodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgbmV3IFVJIG5vZGUgdG8gdGhlIGVuZCBvZiB0aGUgb2xkIG9uZS5cbiAgICogT25jZSBhcHBlbmRlZCBhIG5ldyBVSSBub2RlLCB0aGUgcHJldmlvdXMgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoPGRpdj5oZWxsbzwvZGl2PilcbiAgICogdWkuYXBwZW5kKDxkaXY+d29ybGQ8L2Rpdj4pXG4gICAqXG4gICAqIC8vIFRoZSBVSSBub2RlIHdpbGwgYmU6XG4gICAqIC8vIDw+XG4gICAqIC8vICAgPGRpdj5oZWxsbzwvZGl2PlxuICAgKiAvLyAgIDxkaXY+d29ybGQ8L2Rpdj5cbiAgICogLy8gPC8+XG4gICAqIGBgYFxuICAgKi9cbiAgYXBwZW5kKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBVSSBzdHJlYW0uXG4gICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSBhbmQgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IGNvbXBvbmVudC5cbiAgICovXG4gIGVycm9yKGVycm9yOiBhbnkpOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgVUkgbm9kZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dCBhbnkgcGFyYW1ldGVycyBvciB3aXRoIGEgbmV3IFVJIG5vZGUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgKiBPbmNlIGNhbGxlZCwgdGhlIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAqL1xuICBkb25lKC4uLmFyZ3M6IFtSZWFjdC5SZWFjdE5vZGVdIHwgW10pOiBTdHJlYW1hYmxlVUlXcmFwcGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwaWVjZSBvZiBjaGFuZ2FibGUgVUkgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgaXQgY2FuIGJlIHJlbmRlcmVkIGFzIGEgbm9ybWFsIFJlYWN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsVmFsdWU/OiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgeyByb3csIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlKTtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVUkgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGNvbnN0IHN0cmVhbWFibGU6IFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gICAgdmFsdWU6IHJvdyxcbiAgICB1cGRhdGUodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0J3MgcmVmZXJlbnRpYWxseSBlcXVhbC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBjdXJyZW50VmFsdWUsIGRvbmU6IGZhbHNlLCBuZXh0OiByZXNvbHZhYmxlLnByb21pc2UgfSk7XG4gICAgICByZXNvbHZlID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVqZWN0ID0gcmVzb2x2YWJsZS5yZWplY3Q7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGFwcGVuZCh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6IGZhbHNlLCBhcHBlbmQ6IHRydWUsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZXJyb3IoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICByZWplY3QoZXJyb3IpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGRvbmUoLi4uYXJnczogW10gfCBbUmVhY3QuUmVhY3ROb2RlXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IGFyZ3NbMF0sIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBjdXJyZW50VmFsdWUsIGRvbmU6IHRydWUgfSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHN0cmVhbWFibGU7XG59XG5cbmNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DSyA9IFN5bWJvbCgnc3RyZWFtYWJsZS52YWx1ZS5sb2NrJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlZCwgY2hhbmdhYmxlIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIHRoZSB2YWx1ZSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSByZWFkU3RyZWFtYWJsZVZhbHVlKCkgQVBJLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWU8VCA9IGFueSwgRSA9IGFueT4oXG4gIGluaXRpYWxWYWx1ZT86IFQgfCBSZWFkYWJsZVN0cmVhbTxUPixcbikge1xuICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID1cbiAgICBpbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fFxuICAgICh0eXBlb2YgaW5pdGlhbFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgaW5pdGlhbFZhbHVlICE9PSBudWxsICYmXG4gICAgICAnZ2V0UmVhZGVyJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAnbG9ja2VkJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUubG9ja2VkID09PSAnYm9vbGVhbicpO1xuXG4gIGlmICghaXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KCk7XG5cbiAgLy8gU2luY2UgdGhlIHN0cmVhbWFibGUgdmFsdWUgd2lsbCBiZSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtLCBpdCdzIG5vdCBhbGxvd2VkXG4gIC8vIHRvIHVwZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkgYXMgdGhhdCBpbnRyb2R1Y2VzIHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgLy8gdW5leHBlY3RlZCBiZWhhdmlvci5cbiAgLy8gV2UgbG9jayB0aGUgdmFsdWUgdG8gcHJldmVudCBhbnkgdXBkYXRlcyBmcm9tIHRoZSB1c2VyLlxuICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uc3VtZSB0aGUgcmVhZGFibGUgc3RyZWFtIGFuZCB1cGRhdGUgdGhlIHZhbHVlLlxuICAgICAgY29uc3QgcmVhZGVyID0gaW5pdGlhbFZhbHVlLmdldFJlYWRlcigpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5sb2NrIHRoZSB2YWx1ZSB0byBhbGxvdyB1cGRhdGVzLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS5hcHBlbmQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvY2sgdGhlIHZhbHVlIGFnYWluLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZG9uZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZXJyb3IoZSk7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBzdHJlYW1hYmxlVmFsdWU7XG59XG5cbi8vIEl0J3MgbmVjZXNzYXJ5IHRvIGRlZmluZSB0aGUgdHlwZSBtYW51YWxseSBoZXJlLCBvdGhlcndpc2UgVHlwZVNjcmlwdCBjb21waWxlclxuLy8gd2lsbCBub3QgYmUgYWJsZSB0byBpbmZlciB0aGUgY29ycmVjdCByZXR1cm4gdHlwZSBhcyBpdCdzIGNpcmN1bGFyLlxudHlwZSBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+ID0ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmRcbiAgICogcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC4gVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlXG4gICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFN0cmVhbWFibGVWYWx1ZTxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCB2YWx1ZSB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogVCk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgZGVsdGEgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHZhbHVlLiBJdFxuICAgKiByZXF1aXJlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZSB0byBiZSBhIHN0cmluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoJ2hlbGxvJyk7XG4gICAqIHN0cmVhbWFibGUuYXBwZW5kKCcgd29ybGQnKTtcbiAgICpcbiAgICogLy8gVGhlIHZhbHVlIHdpbGwgYmUgJ2hlbGxvIHdvcmxkJ1xuICAgKiBgYGBcbiAgICovXG4gIGFwcGVuZCh2YWx1ZTogVCk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHZhbHVlIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIHdoZW4gY29uc3VtZWQgdmlhXG4gICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYC5cbiAgICovXG4gIGVycm9yKGVycm9yOiBhbnkpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgdmFsdWUgYXMgZmluYWxpemVkLiBZb3UgY2FuIGVpdGhlciBjYWxsIGl0IHdpdGhvdXRcbiAgICogYW55IHBhcmFtZXRlcnMgb3Igd2l0aCBhIG5ldyB2YWx1ZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgdmFsdWUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2VcbiAgICogd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAqL1xuICBkb25lKC4uLmFyZ3M6IFtUXSB8IFtdKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogQGludGVybmFsIFRoaXMgaXMgYW4gaW50ZXJuYWwgbG9jayB0byBwcmV2ZW50IHRoZSB2YWx1ZSBmcm9tIGJlaW5nXG4gICAqIHVwZGF0ZWQgYnkgdGhlIHVzZXIuXG4gICAqL1xuICBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXTogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCA9IGFueSwgRSA9IGFueT4oaW5pdGlhbFZhbHVlPzogVCkge1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCBsb2NrZWQgPSBmYWxzZTtcbiAgbGV0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+KCk7XG5cbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGN1cnJlbnRFcnJvcjogRSB8IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRQcm9taXNlOiB0eXBlb2YgcmVzb2x2YWJsZS5wcm9taXNlIHwgdW5kZWZpbmVkID1cbiAgICByZXNvbHZhYmxlLnByb21pc2U7XG4gIGxldCBjdXJyZW50UGF0Y2hWYWx1ZTogU3RyZWFtYWJsZVBhdGNoO1xuXG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2Q6IHN0cmluZykge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnOiBWYWx1ZSBzdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQuJyk7XG4gICAgfVxuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgbWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGxvY2tlZCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHdhcm5pbmdUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoZSBzdHJlYW1hYmxlIHZhbHVlIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuJyxcbiAgICAgICAgKTtcbiAgICAgIH0sIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlZChpbml0aWFsQ2h1bms/OiBib29sZWFuKTogU3RyZWFtYWJsZVZhbHVlPFQsIEU+IHtcbiAgICAvLyBUaGlzIG1ha2VzIHRoZSBwYXlsb2FkIG11Y2ggc21hbGxlciBpZiB0aGVyZSdyZSBtdXRhdGl2ZSB1cGRhdGVzIGJlZm9yZSB0aGUgZmlyc3QgcmVhZC5cbiAgICBsZXQgaW5pdDogUGFydGlhbDxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+O1xuXG4gICAgaWYgKGN1cnJlbnRFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0geyBlcnJvcjogY3VycmVudEVycm9yIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50UGF0Y2hWYWx1ZSAmJiAhaW5pdGlhbENodW5rKSB7XG4gICAgICAgIGluaXQgPSB7IGRpZmY6IGN1cnJlbnRQYXRjaFZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0ID0geyBjdXJyOiBjdXJyZW50VmFsdWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFByb21pc2UpIHtcbiAgICAgIGluaXQubmV4dCA9IGN1cnJlbnRQcm9taXNlO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsQ2h1bmspIHtcbiAgICAgIGluaXQudHlwZSA9IFNUUkVBTUFCTEVfVkFMVUVfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgYGN1cnJlbnRWYWx1ZWAgYW5kIGBjdXJyZW50UGF0Y2hWYWx1ZWAgaWYgbmVlZGVkLlxuICBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZTogVCkge1xuICAgIC8vIElmIHdlIGNhbiBvbmx5IHNlbmQgYSBwYXRjaCBvdmVyIHRoZSB3aXJlLCBpdCdzIGJldHRlciB0byBkbyBzby5cbiAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZS5zbGljZShjdXJyZW50VmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHN0cmVhbWFibGU6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT4gPSB7XG4gICAgc2V0IFtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdKHN0YXRlOiBib29sZWFuKSB7XG4gICAgICBsb2NrZWQgPSBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVkKHRydWUpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlOiBUKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICAgICAgdXBkYXRlVmFsdWVTdGF0ZXModmFsdWUpO1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgYXBwZW5kKHZhbHVlOiBUKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSBjdXJyZW50IHZhbHVlIGlzIG5vdCBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7dHlwZW9mIGN1cnJlbnRWYWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiB2YWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlXTtcbiAgICAgICAgKGN1cnJlbnRWYWx1ZSBhcyBzdHJpbmcpID0gY3VycmVudFZhbHVlICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudEVycm9yID0gZXJyb3I7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHsgZXJyb3IgfSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtUXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHt9KTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3RyZWFtYWJsZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJLCBjcmVhdGVTdHJlYW1hYmxlVmFsdWUgfTtcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xudHlwZSBSZW5kZXJlcjxUPiA9IChcbiAgcHJvcHM6IFQsXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG4vKipcbiAqIGByZW5kZXJgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBzb21lIExMTXMuXG4gKiBUaGlzIEFQSSBvbmx5IHN1cHBvcnRzIE9wZW5BSSdzIEdQVCBtb2RlbHMgd2l0aCBGdW5jdGlvbiBDYWxsaW5nIGFuZCBBc3Npc3RhbnRzIFRvb2xzLFxuICogcGxlYXNlIHVzZSBgc3RyZWFtVUlgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgcHJvdmlkZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBgc3RyZWFtVUlgIEFQSSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFJIFNESyBDb3JlIEFQSXNcbiAqIGFuZCBmdXR1cmUgZmVhdHVyZXMuIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyPFxuICBUUyBleHRlbmRzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogei5TY2hlbWE7XG4gIH0gPSB7fSxcbiAgRlMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4+KG9wdGlvbnM6IHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBuYW1lIHRvIHVzZS4gTXVzdCBiZSBPcGVuQUkgU0RLIGNvbXBhdGlibGUuIFRvb2xzIGFuZCBGdW5jdGlvbnMgYXJlIG9ubHkgc3VwcG9ydGVkXG4gICAqIEdQVCBtb2RlbHMgKDMuNS80KSwgT3BlbkFJIEFzc2lzdGFudHMsIE1pc3RyYWwgc21hbGwgYW5kIGxhcmdlLCBhbmQgRmlyZXdvcmtzIGZpcmVmdW5jdGlvbi12MS5cbiAgICpcbiAgICogQGV4YW1wbGUgXCJncHQtMy41LXR1cmJvXCJcbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcHJvdmlkZXIgaW5zdGFuY2UgdG8gdXNlLiBDdXJyZW50bHkgdGhlIG9ubHkgcHJvdmlkZXIgYXZhaWxhYmxlIGlzIE9wZW5BSS5cbiAgICogVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgbW9kZWwgbmFtZS5cbiAgICovXG4gIHByb3ZpZGVyOiBPcGVuQUk7XG4gIG1lc3NhZ2VzOiBQYXJhbWV0ZXJzPFxuICAgIHR5cGVvZiBPcGVuQUkucHJvdG90eXBlLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlXG4gID5bMF1bJ21lc3NhZ2VzJ107XG4gIHRleHQ/OiBSZW5kZXJlcjx7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNvIGZhci5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICovXG4gICAgZGVsdGE6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgKi9cbiAgICBkb25lOiBib29sZWFuO1xuICB9PjtcbiAgdG9vbHM/OiB7XG4gICAgW25hbWUgaW4ga2V5b2YgVFNdOiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IFRTW25hbWVdO1xuICAgICAgcmVuZGVyOiBSZW5kZXJlcjx6LmluZmVyPFRTW25hbWVdPj47XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb25zPzoge1xuICAgIFtuYW1lIGluIGtleW9mIEZTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBGU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxGU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGluaXRpYWw/OiBSZWFjdE5vZGU7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xufSk6IFJlYWN0Tm9kZSB7XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKG9wdGlvbnMuaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0ID0gb3B0aW9ucy50ZXh0XG4gICAgPyBvcHRpb25zLnRleHRcbiAgICA6ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT4gY29udGVudDtcblxuICBjb25zdCBmdW5jdGlvbnMgPSBvcHRpb25zLmZ1bmN0aW9uc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5mdW5jdGlvbnMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHpvZFRvSnNvblNjaGVtYShwYXJhbWV0ZXJzKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRvb2xzID0gb3B0aW9ucy50b29sc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50b29scykubWFwKFxuICAgICAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPFxuICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICB1bmtub3duXG4gICAgICAgICAgICAgID4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGZ1bmN0aW9ucyAmJiB0b29scykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbid0IGhhdmUgYm90aCBmdW5jdGlvbnMgYW5kIHRvb2xzIGRlZmluZWQuIFBsZWFzZSBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci5cIixcbiAgICApO1xuICB9XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBhbnksXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoYXNGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50ID0gJyc7XG5cbiAgICBjb25zdW1lU3RyZWFtKFxuICAgICAgT3BlbkFJU3RyZWFtKFxuICAgICAgICAoYXdhaXQgb3B0aW9ucy5wcm92aWRlci5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgIC4uLihmdW5jdGlvbnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pKSBhcyBhbnksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZnVuY3Rpb25DYWxsUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxQYXlsb2FkLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mdW5jdGlvbnM/LltmdW5jdGlvbkNhbGxQYXlsb2FkLm5hbWUgYXMgYW55XVxuICAgICAgICAgICAgICAgICAgICAgID8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25Ub29sQ2FsbCh0b29sQ2FsbFBheWxvYWQ6IGFueSkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBuZWVkIFByb21pc2UuYWxsIGhlcmU/XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgICB0b29sLmZ1bmMuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbHM/Llt0b29sLmZ1bmMubmFtZSBhcyBhbnldPy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgb25UZXh0KGNodW5rKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiBjaHVuayB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbkZpbmFsKCkge1xuICAgICAgICAgICAgaWYgKGhhc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogdHJ1ZSB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgIHVpLmRvbmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9KSgpO1xuXG4gIHJldHVybiB1aS52YWx1ZTtcbn1cbiIsImltcG9ydCB7IEFQSUNhbGxFcnJvciwgUmV0cnlFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi9kZWxheSc7XG5cbmV4cG9ydCB0eXBlIFJldHJ5RnVuY3Rpb24gPSA8T1VUUFVUPihcbiAgZm46ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4sXG4pID0+IFByb21pc2VMaWtlPE9VVFBVVD47XG5cbi8qKlxuVGhlIGByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZgIHN0cmF0ZWd5IHJldHJpZXMgYSBmYWlsZWQgQVBJIGNhbGwgd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmLlxuWW91IGNhbiBjb25maWd1cmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIHRoZSBpbml0aWFsIGRlbGF5LCBhbmQgdGhlIGJhY2tvZmYgZmFjdG9yLlxuICovXG5leHBvcnQgY29uc3QgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID1cbiAgKHtcbiAgICBtYXhSZXRyaWVzID0gMixcbiAgICBpbml0aWFsRGVsYXlJbk1zID0gMjAwMCxcbiAgICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgfSA9IHt9KTogUmV0cnlGdW5jdGlvbiA9PlxuICBhc3luYyA8T1VUUFVUPihmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+KSA9PlxuICAgIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgfSk7XG5cbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmY8T1VUUFVUPihcbiAgZjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbiAge1xuICAgIG1heFJldHJpZXMsXG4gICAgZGVsYXlJbk1zLFxuICAgIGJhY2tvZmZGYWN0b3IsXG4gIH06IHsgbWF4UmV0cmllczogbnVtYmVyOyBkZWxheUluTXM6IG51bWJlcjsgYmFja29mZkZhY3RvcjogbnVtYmVyIH0sXG4gIGVycm9yczogdW5rbm93bltdID0gW10sXG4pOiBQcm9taXNlPE9VVFBVVD4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCByZXRyeSB3aGVuIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIHJldHJpZXMgYXJlIGRpc2FibGVkXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcblxuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246ICdtYXhSZXRyaWVzRXhjZWVkZWQnLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiZcbiAgICAgIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmXG4gICAgICB0cnlOdW1iZXIgPD0gbWF4UmV0cmllc1xuICAgICkge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIGEgbm9uLXJldHJ5YWJsZSBlcnJvciBvY2N1cnMgb24gdGhlIGZpcnN0IHRyeVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiAnZXJyb3JOb3RSZXRyeWFibGUnLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuIiwiaW1wb3J0IHtcbiAgTGFuZ3VhZ2VNb2RlbFYxSW1hZ2VQYXJ0LFxuICBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlLFxuICBMYW5ndWFnZU1vZGVsVjFQcm9tcHQsXG4gIExhbmd1YWdlTW9kZWxWMVRleHRQYXJ0LFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tICcuLi9wcm9tcHQvbWVzc2FnZSc7XG5pbXBvcnQgeyBkZXRlY3RJbWFnZU1pbWVUeXBlIH0gZnJvbSAnLi4vdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUnO1xuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tICcuLi91dGlsL2Rvd25sb2FkJztcbmltcG9ydCB7IEltYWdlUGFydCwgVGV4dFBhcnQgfSBmcm9tICcuL2NvbnRlbnQtcGFydCc7XG5pbXBvcnQgeyBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkgfSBmcm9tICcuL2RhdGEtY29udGVudCc7XG5pbXBvcnQgeyBWYWxpZGF0ZWRQcm9tcHQgfSBmcm9tICcuL2dldC12YWxpZGF0ZWQtcHJvbXB0JztcbmltcG9ydCB7IEludmFsaWRNZXNzYWdlUm9sZUVycm9yIH0gZnJvbSAnLi9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvcic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgcHJvbXB0LFxuICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID0gdHJ1ZSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkLFxufToge1xuICBwcm9tcHQ6IFZhbGlkYXRlZFByb21wdDtcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbj86IHR5cGVvZiBkb3dubG9hZDtcbn0pOiBQcm9taXNlPExhbmd1YWdlTW9kZWxWMVByb21wdD4ge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXM6IExhbmd1YWdlTW9kZWxWMVByb21wdCA9IFtdO1xuXG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH0pO1xuICB9XG5cbiAgY29uc3QgZG93bmxvYWRlZEltYWdlcyA9XG4gICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyB8fCBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbFxuICAgICAgPyBudWxsXG4gICAgICA6IGF3YWl0IGRvd25sb2FkSW1hZ2VzKHByb21wdC5tZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbik7XG5cbiAgY29uc3QgcHJvbXB0VHlwZSA9IHByb21wdC50eXBlO1xuICBzd2l0Y2ggKHByb21wdFR5cGUpIHtcbiAgICBjYXNlICdwcm9tcHQnOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBwcm9tcHQucHJvbXB0IH1dLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdtZXNzYWdlcyc6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKFxuICAgICAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKFxuICAgICAgICAgIChtZXNzYWdlKTogTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSA9PlxuICAgICAgICAgICAgY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEltYWdlcyksXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBwcm9tcHRUeXBlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIENvcmVNZXNzYWdlIHRvIGEgTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgQ29yZU1lc3NhZ2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBkb3dubG9hZGVkSW1hZ2VzIEEgbWFwIG9mIGltYWdlIFVSTHMgdG8gdGhlaXIgZG93bmxvYWRlZCBkYXRhLiBPbmx5XG4gKiAgIGF2YWlsYWJsZSBpZiB0aGUgbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBpbWFnZSBVUkxzLCBudWxsIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlKFxuICBtZXNzYWdlOiBDb3JlTWVzc2FnZSxcbiAgZG93bmxvYWRlZEltYWdlczogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7IGRhdGE6IFVpbnQ4QXJyYXkgfVxuICA+IHwgbnVsbCxcbik6IExhbmd1YWdlTW9kZWxWMU1lc3NhZ2Uge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlICdzeXN0ZW0nOiB7XG4gICAgICByZXR1cm4geyByb2xlOiAnc3lzdGVtJywgY29udGVudDogbWVzc2FnZS5jb250ZW50IH07XG4gICAgfVxuXG4gICAgY2FzZSAndXNlcic6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAgIChwYXJ0KTogTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnQgfCBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnQgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRlZEltYWdlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkZWRJbWFnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRlZEltYWdlc1twYXJ0LmltYWdlLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGRvd25sb2FkZWRJbWFnZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlID8/IGRvd25sb2FkZWRJbWFnZS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gY29udmVydCBzdHJpbmcgaW1hZ2UgcGFydHMgdG8gdXJsc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC5pbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocGFydC5pbWFnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlICdodHRwOic6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaHR0cHM6Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkZWRJbWFnZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkZWRJbWFnZSA9IGRvd25sb2FkZWRJbWFnZXNbcGFydC5pbWFnZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogZG93bmxvYWRlZEltYWdlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUgPz8gZG93bmxvYWRlZEltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkYXRhOic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gcGFydC5pbWFnZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGhlYWRlci5zcGxpdCgnOycpWzBdLnNwbGl0KCc6JylbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2dldEVycm9yTWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBVUkwgcHJvdG9jb2w6ICR7dXJsLnByb3RvY29sfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoX2lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGEgVVJMXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VVaW50OCA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShwYXJ0LmltYWdlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVWludDgsXG4gICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZSA/PyBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlVWludDgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlICdhc3Npc3RhbnQnOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgcGFydCA9PiBwYXJ0LnR5cGUgIT09ICd0ZXh0JyB8fCBwYXJ0LnRleHQgIT09ICcnLFxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlICd0b29sJzoge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSByb2xlO1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZXNzYWdlUm9sZUVycm9yKHsgcm9sZTogX2V4aGF1c3RpdmVDaGVjayB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRJbWFnZXMoXG4gIG1lc3NhZ2VzOiBDb3JlTWVzc2FnZVtdLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uOiB0eXBlb2YgZG93bmxvYWQsXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHsgbWltZVR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDsgZGF0YTogVWludDhBcnJheSB9Pj4ge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXNcbiAgICAuZmlsdGVyKG1lc3NhZ2UgPT4gbWVzc2FnZS5yb2xlID09PSAndXNlcicpXG4gICAgLm1hcChtZXNzYWdlID0+IG1lc3NhZ2UuY29udGVudClcbiAgICAuZmlsdGVyKChjb250ZW50KTogY29udGVudCBpcyBBcnJheTxUZXh0UGFydCB8IEltYWdlUGFydD4gPT5cbiAgICAgIEFycmF5LmlzQXJyYXkoY29udGVudCksXG4gICAgKVxuICAgIC5mbGF0KClcbiAgICAuZmlsdGVyKChwYXJ0KTogcGFydCBpcyBJbWFnZVBhcnQgPT4gcGFydC50eXBlID09PSAnaW1hZ2UnKVxuICAgIC5tYXAocGFydCA9PiBwYXJ0LmltYWdlKVxuICAgIC5tYXAocGFydCA9PlxuICAgICAgLy8gc3VwcG9ydCBzdHJpbmcgdXJscyBpbiBpbWFnZSBwYXJ0czpcbiAgICAgIHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgKHBhcnQuc3RhcnRzV2l0aCgnaHR0cDonKSB8fCBwYXJ0LnN0YXJ0c1dpdGgoJ2h0dHBzOicpKVxuICAgICAgICA/IG5ldyBVUkwocGFydClcbiAgICAgICAgOiBwYXJ0LFxuICAgIClcbiAgICAuZmlsdGVyKChpbWFnZSk6IGltYWdlIGlzIFVSTCA9PiBpbWFnZSBpbnN0YW5jZW9mIFVSTCk7XG5cbiAgLy8gZG93bmxvYWQgaW1hZ2VzIGluIHBhcmFsbGVsOlxuICBjb25zdCBkb3dubG9hZGVkSW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdXJscy5tYXAoYXN5bmMgdXJsID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pLFxuICAgIH0pKSxcbiAgKTtcblxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKSxcbiAgKTtcbn1cbiIsImNvbnN0IG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2dpZicgYXMgY29uc3QsIGJ5dGVzOiBbMHg0NywgMHg0OSwgMHg0Nl0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3BuZycgYXMgY29uc3QsIGJ5dGVzOiBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0N10gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2pwZWcnIGFzIGNvbnN0LCBieXRlczogWzB4ZmYsIDB4ZDhdIH0sXG4gIHsgbWltZVR5cGU6ICdpbWFnZS93ZWJwJyBhcyBjb25zdCwgYnl0ZXM6IFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoXG4gIGltYWdlOiBVaW50OEFycmF5LFxuKTogJ2ltYWdlL2pwZWcnIHwgJ2ltYWdlL3BuZycgfCAnaW1hZ2UvZ2lmJyB8ICdpbWFnZS93ZWJwJyB8IHVuZGVmaW5lZCB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoXG4gICAgICBpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmXG4gICAgICBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgRG93bmxvYWRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoe1xuICB1cmwsXG4gIGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaCxcbn06IHtcbiAgdXJsOiBVUkw7XG4gIGZldGNoSW1wbGVtZW50YXRpb24/OiB0eXBlb2YgZmV0Y2g7XG59KTogUHJvbWlzZTx7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59PiB7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24odXJsVGV4dCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSA/PyB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0Rvd25sb2FkRXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7IHVybDogdXJsVGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5cbi8qKlxuRGF0YSBjb250ZW50LiBDYW4gZWl0aGVyIGJlIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YUNvbnRlbnQgPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBCdWZmZXI7XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50OiBEYXRhQ29udGVudCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cblxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cblxuLyoqXG5Db252ZXJ0cyBkYXRhIGNvbnRlbnQgdG8gYSBVaW50OEFycmF5LlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgY29udGVudDogRGF0YUNvbnRlbnQsXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuJyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nIG9mIHRleHQuXG4gKlxuICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBUaGUgVWludDhBcnJheSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvVGV4dCh1aW50OEFycmF5OiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0Jyk7XG4gIH1cbn1cbiIsImV4cG9ydCBjbGFzcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVhZG9ubHkgcm9sZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gLFxuICB9OiB7XG4gICAgcm9sZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcblxuICAgIHRoaXMubmFtZSA9ICdBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvcic7XG5cbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG5cbiAgc3RhdGljIGlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoXG4gICAgZXJyb3I6IHVua25vd24sXG4gICk6IGVycm9yIGlzIEludmFsaWRNZXNzYWdlUm9sZUVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gJ0FJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yJyAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcikucm9sZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tICcuL21lc3NhZ2UnO1xuaW1wb3J0IHsgUHJvbXB0IH0gZnJvbSAnLi9wcm9tcHQnO1xuXG5leHBvcnQgdHlwZSBWYWxpZGF0ZWRQcm9tcHQgPVxuICB8IHtcbiAgICAgIHR5cGU6ICdwcm9tcHQnO1xuICAgICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgICBtZXNzYWdlczogdW5kZWZpbmVkO1xuICAgICAgc3lzdGVtPzogc3RyaW5nO1xuICAgIH1cbiAgfCB7XG4gICAgICB0eXBlOiAnbWVzc2FnZXMnO1xuICAgICAgcHJvbXB0OiB1bmRlZmluZWQ7XG4gICAgICBtZXNzYWdlczogQ29yZU1lc3NhZ2VbXTtcbiAgICAgIHN5c3RlbT86IHN0cmluZztcbiAgICB9O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUHJvbXB0KHByb21wdDogUHJvbXB0KTogVmFsaWRhdGVkUHJvbXB0IHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogJ3Byb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWQnLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogJ3Byb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZScsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcHJvbXB0Lm1lc3NhZ2VzKSB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlID09PSAnc3lzdGVtJyAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZTogJ3N5c3RlbSBtZXNzYWdlIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9tcHQucHJvbXB0ICE9IG51bGxcbiAgICA/IHtcbiAgICAgICAgdHlwZTogJ3Byb21wdCcsXG4gICAgICAgIHByb21wdDogcHJvbXB0LnByb21wdCxcbiAgICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgfVxuICAgIDoge1xuICAgICAgICB0eXBlOiAnbWVzc2FnZXMnLFxuICAgICAgICBwcm9tcHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyEsIC8vIG9ubHkgcG9zc2libGUgY2FzZSBiYyBvZiBjaGVja3MgYWJvdmVcbiAgICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgfTtcbn1cbiIsImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBDYWxsU2V0dGluZ3MgfSBmcm9tICcuL2NhbGwtc2V0dGluZ3MnO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBjYWxsIHNldHRpbmdzIGFuZCBzZXRzIGRlZmF1bHQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc3RvcFNlcXVlbmNlcyxcbiAgc2VlZCxcbiAgbWF4UmV0cmllcyxcbn06IENhbGxTZXR0aW5ncyk6IENhbGxTZXR0aW5ncyB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4VG9rZW5zJyxcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogJ21heFRva2VucyBtdXN0IGJlID49IDEnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAndGVtcGVyYXR1cmUnLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6ICd0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0b3BQJyxcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6ICd0b3BQIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdwcmVzZW5jZVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAncHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogJ2ZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdzZWVkJyxcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6ICdzZWVkIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhSZXRyaWVzJyxcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSA+PSAwJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSA/PyAwLFxuICAgIHRvcFAsXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczpcbiAgICAgIHN0b3BTZXF1ZW5jZXMgIT0gbnVsbCAmJiBzdG9wU2VxdWVuY2VzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBzdG9wU2VxdWVuY2VzXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyA/PyAyLFxuICB9O1xufVxuIiwiLyoqXG5SZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gYSBwcm9tcHQgYW5kIGNvbXBsZXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBsZXRpb25Ub2tlblVzYWdlID0ge1xuICAvKipcblRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdFRva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuVGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgY29tcGxldGlvbi5cbiAqL1xuICBjb21wbGV0aW9uVG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG5UaGUgdG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIChwcm9tcHRUb2tlbnMgKyBjb21wbGV0aW9uVG9rZW5zKS5cbiAgICovXG4gIHRvdGFsVG9rZW5zOiBudW1iZXI7XG59O1xuXG4vKipcblJlcHJlc2VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiBhbiBlbWJlZGRpbmcuXG4gKi9cbmV4cG9ydCB0eXBlIEVtYmVkZGluZ1Rva2VuVXNhZ2UgPSB7XG4gIC8qKlxuVGhlIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgZW1iZWRkaW5nLlxuICAgKi9cbiAgdG9rZW5zOiBudW1iZXI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UodXNhZ2U6IHtcbiAgcHJvbXB0VG9rZW5zOiBudW1iZXI7XG4gIGNvbXBsZXRpb25Ub2tlbnM6IG51bWJlcjtcbn0pOiBDb21wbGV0aW9uVG9rZW5Vc2FnZSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VuczogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zICsgdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgfTtcbn1cbiIsImltcG9ydCB7IFZhbGlkYXRvciwgdmFsaWRhdG9yU3ltYm9sIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyBKU09OU2NoZW1hNyB9IGZyb20gJ2pzb24tc2NoZW1hJztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tICd6b2QtdG8tanNvbi1zY2hlbWEnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWFyayBzY2hlbWFzIHNvIHdlIGNhbiBzdXBwb3J0IGJvdGggWm9kIGFuZCBjdXN0b20gc2NoZW1hcy5cbiAqL1xuY29uc3Qgc2NoZW1hU3ltYm9sID0gU3ltYm9sKCd2ZXJjZWwuYWkuc2NoZW1hJyk7XG5cbmV4cG9ydCB0eXBlIFNjaGVtYTxPQkpFQ1QgPSB1bmtub3duPiA9IFZhbGlkYXRvcjxPQkpFQ1Q+ICYge1xuICAvKipcbiAgICogVXNlZCB0byBtYXJrIHNjaGVtYXMgc28gd2UgY2FuIHN1cHBvcnQgYm90aCBab2QgYW5kIGN1c3RvbSBzY2hlbWFzLlxuICAgKi9cbiAgW3NjaGVtYVN5bWJvbF06IHRydWU7XG5cbiAgLyoqXG4gICAqIFNjaGVtYSB0eXBlIGZvciBpbmZlcmVuY2UuXG4gICAqL1xuICBfdHlwZTogT0JKRUNUO1xuXG4gIC8qKlxuICAgKiBUaGUgSlNPTiBTY2hlbWEgZm9yIHRoZSBzY2hlbWEuIEl0IGlzIHBhc3NlZCB0byB0aGUgcHJvdmlkZXJzLlxuICAgKi9cbiAgcmVhZG9ubHkganNvblNjaGVtYTogSlNPTlNjaGVtYTc7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNjaGVtYSB1c2luZyBhIEpTT04gU2NoZW1hLlxuICpcbiAqIEBwYXJhbSBqc29uU2NoZW1hIFRoZSBKU09OIFNjaGVtYSBmb3IgdGhlIHNjaGVtYS5cbiAqIEBwYXJhbSBvcHRpb25zLnZhbGlkYXRlIE9wdGlvbmFsLiBBIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBzY2hlbWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uU2NoZW1hPE9CSkVDVCA9IHVua25vd24+KFxuICBqc29uU2NoZW1hOiBKU09OU2NoZW1hNyxcbiAge1xuICAgIHZhbGlkYXRlLFxuICB9OiB7XG4gICAgdmFsaWRhdGU/OiAoXG4gICAgICB2YWx1ZTogdW5rbm93bixcbiAgICApID0+IHsgc3VjY2VzczogdHJ1ZTsgdmFsdWU6IE9CSkVDVCB9IHwgeyBzdWNjZXNzOiBmYWxzZTsgZXJyb3I6IEVycm9yIH07XG4gIH0gPSB7fSxcbik6IFNjaGVtYTxPQkpFQ1Q+IHtcbiAgcmV0dXJuIHtcbiAgICBbc2NoZW1hU3ltYm9sXTogdHJ1ZSxcbiAgICBfdHlwZTogdW5kZWZpbmVkIGFzIE9CSkVDVCwgLy8gc2hvdWxkIG5ldmVyIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSxcbiAgICBqc29uU2NoZW1hLFxuICAgIHZhbGlkYXRlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1NjaGVtYSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFNjaGVtYSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgc2NoZW1hU3ltYm9sIGluIHZhbHVlICYmXG4gICAgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJlxuICAgICdqc29uU2NoZW1hJyBpbiB2YWx1ZSAmJlxuICAgICd2YWxpZGF0ZScgaW4gdmFsdWVcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzU2NoZW1hPE9CSkVDVD4oXG4gIHNjaGVtYTogei5TY2hlbWE8T0JKRUNUPiB8IFNjaGVtYTxPQkpFQ1Q+LFxuKTogU2NoZW1hPE9CSkVDVD4ge1xuICByZXR1cm4gaXNTY2hlbWEoc2NoZW1hKSA/IHNjaGVtYSA6IHpvZFNjaGVtYShzY2hlbWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gem9kU2NoZW1hPE9CSkVDVD4oem9kU2NoZW1hOiB6LlNjaGVtYTxPQkpFQ1Q+KTogU2NoZW1hPE9CSkVDVD4ge1xuICByZXR1cm4ganNvblNjaGVtYShcbiAgICAvLyB3ZSBhc3N1bWUgdGhhdCB6b2RUb0pzb25TY2hlbWEgd2lsbCByZXR1cm4gYSB2YWxpZCBKU09OU2NoZW1hNzpcbiAgICB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hKSBhcyBKU09OU2NoZW1hNyxcbiAgICB7XG4gICAgICB2YWxpZGF0ZTogdmFsdWUgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzXG4gICAgICAgICAgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQuZGF0YSB9XG4gICAgICAgICAgOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9LFxuICAgIH0sXG4gICk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChcbiAgb2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCB8IG51bGwsXG4pOiBvYmplY3QgaXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuIiwiaW1wb3J0IHtcbiAgTGFuZ3VhZ2VNb2RlbFYxRnVuY3Rpb25Ub29sLFxuICBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlLFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENvcmVUb29sIH0gZnJvbSAnLi4vdG9vbC90b29sJztcbmltcG9ydCB7IENvcmVUb29sQ2hvaWNlIH0gZnJvbSAnLi4vdHlwZXMvbGFuZ3VhZ2UtbW9kZWwnO1xuaW1wb3J0IHsgaXNOb25FbXB0eU9iamVjdCB9IGZyb20gJy4uL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdCc7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gJy4uL3V0aWwvc2NoZW1hJztcblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2U8XG4gIFRPT0xTIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgQ29yZVRvb2w+LFxuPih7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxufToge1xuICB0b29sczogVE9PTFMgfCB1bmRlZmluZWQ7XG4gIHRvb2xDaG9pY2U6IENvcmVUb29sQ2hvaWNlPFRPT0xTPiB8IHVuZGVmaW5lZDtcbn0pOiB7XG4gIHRvb2xzOiBMYW5ndWFnZU1vZGVsVjFGdW5jdGlvblRvb2xbXSB8IHVuZGVmaW5lZDtcbiAgdG9vbENob2ljZTogTGFuZ3VhZ2VNb2RlbFYxVG9vbENob2ljZSB8IHVuZGVmaW5lZDtcbn0ge1xuICBpZiAoIWlzTm9uRW1wdHlPYmplY3QodG9vbHMpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xzOiB1bmRlZmluZWQsXG4gICAgICB0b29sQ2hvaWNlOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9vbHM6IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5tYXAoKFtuYW1lLCB0b29sXSkgPT4gKHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbicgYXMgY29uc3QsXG4gICAgICBuYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYSh0b29sLnBhcmFtZXRlcnMpLmpzb25TY2hlbWEsXG4gICAgfSkpLFxuICAgIHRvb2xDaG9pY2U6XG4gICAgICB0b29sQ2hvaWNlID09IG51bGxcbiAgICAgICAgPyB7IHR5cGU6ICdhdXRvJyB9XG4gICAgICAgIDogdHlwZW9mIHRvb2xDaG9pY2UgPT09ICdzdHJpbmcnXG4gICAgICAgID8geyB0eXBlOiB0b29sQ2hvaWNlIH1cbiAgICAgICAgOiB7IHR5cGU6ICd0b29sJyBhcyBjb25zdCwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgYXMgc3RyaW5nIH0sXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVQYXJzZXIsXG4gIHR5cGUgRXZlbnRTb3VyY2VQYXJzZXIsXG4gIHR5cGUgUGFyc2VkRXZlbnQsXG4gIHR5cGUgUmVjb25uZWN0SW50ZXJ2YWwsXG59IGZyb20gJ2V2ZW50c291cmNlLXBhcnNlcic7XG5pbXBvcnQgeyBPcGVuQUlTdHJlYW1DYWxsYmFja3MgfSBmcm9tICcuL29wZW5haS1zdHJlYW0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbFBheWxvYWQge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFyZ3VtZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59XG5leHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsUGF5bG9hZCB7XG4gIHRvb2xzOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0eXBlOiAnZnVuY3Rpb24nO1xuICAgIGZ1bmM6IHtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIGFyZ3VtZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfTtcbiAgfVtdO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgaGVscGVyIGNhbGxiYWNrIG1ldGhvZHMgZm9yIEFJU3RyZWFtIHN0cmVhbSBsaWZlY3ljbGUgZXZlbnRzLlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB7XG4gIC8qKiBgb25TdGFydGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBpbml0aWFsaXplZC4gKi9cbiAgb25TdGFydD86ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uQ29tcGxldGlvbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS4gKi9cbiAgb25Db21wbGV0aW9uPzogKGNvbXBsZXRpb246IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25GaW5hbGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWQgd2l0aCB0aGUgZmluYWwgY29tcGxldGlvbiBtZXNzYWdlLiAqL1xuICBvbkZpbmFsPzogKGNvbXBsZXRpb246IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25Ub2tlbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS4gKi9cbiAgb25Ub2tlbj86ICh0b2tlbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvblRleHRgOiBDYWxsZWQgZm9yIGVhY2ggdGV4dCBjaHVuay4gKi9cbiAgb25UZXh0PzogKHRleHQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgaXMgbm8gbG9uZ2VyIHVzZWQgYW5kIG9ubHkgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgKiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgY29kZS5cbiAgICovXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgQUlTdHJlYW1QYXJzZXIuXG4gKiBAaW50ZXJmYWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgKHR5cGUpIGZyb20gdGhlIHNlcnZlciBzaWRlIGV2ZW50IHN0cmVhbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbVBhcnNlck9wdGlvbnMge1xuICBldmVudD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDdXN0b20gcGFyc2VyIGZvciBBSVN0cmVhbSBkYXRhLlxuICogQGludGVyZmFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgcGFyc2VyLlxuICogQHJldHVybnMge3N0cmluZyB8IHZvaWR9IFRoZSBwYXJzZWQgZGF0YSBvciB2b2lkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtUGFyc2VyIHtcbiAgKGRhdGE6IHN0cmluZywgb3B0aW9uczogQUlTdHJlYW1QYXJzZXJPcHRpb25zKTpcbiAgICB8IHN0cmluZ1xuICAgIHwgdm9pZFxuICAgIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgVHJhbnNmb3JtU3RyZWFtIHRoYXQgcGFyc2VzIGV2ZW50cyBmcm9tIGFuIEV2ZW50U291cmNlIHN0cmVhbSB1c2luZyBhIGN1c3RvbSBwYXJzZXIuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyfSBjdXN0b21QYXJzZXIgLSBGdW5jdGlvbiB0byBoYW5kbGUgZXZlbnQgZGF0YS5cbiAqIEByZXR1cm5zIHtUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgc3RyaW5nPn0gVHJhbnNmb3JtU3RyZWFtIHBhcnNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihcbiAgY3VzdG9tUGFyc2VyPzogQUlTdHJlYW1QYXJzZXIsXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgc3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfT4ge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI6IEV2ZW50U291cmNlUGFyc2VyO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50OiBQYXJzZWRFdmVudCB8IFJlY29ubmVjdEludGVydmFsKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCdkYXRhJyBpbiBldmVudCAmJlxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSAnZXZlbnQnICYmXG4gICAgICAgICAgICAgIGV2ZW50LmRhdGEgPT09ICdbRE9ORV0nKSB8fFxuICAgICAgICAgICAgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICAgIChldmVudCBhcyBhbnkpLmV2ZW50ID09PSAnZG9uZSdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdkYXRhJyBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlclxuICAgICAgICAgICAgICA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbmNvZGVzIGlucHV0IG1lc3NhZ2VzIGFuZCBpbnZva2VzIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIFRoZSB0cmFuc2Zvcm0gc3RyZWFtIHVzZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyB0byBleGVjdXRlIGN1c3RvbSBsb2dpYyBhdCBkaWZmZXJlbnQgc3RhZ2VzIG9mIHRoZSBzdHJlYW0ncyBsaWZlY3ljbGUuXG4gKiAtIGBvblN0YXJ0YDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGluaXRpYWxpemVkLlxuICogLSBgb25Ub2tlbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS5cbiAqIC0gYG9uQ29tcGxldGlvbmA6IENhbGxlZCBldmVyeSB0aW1lIGFuIEFJU3RyZWFtIGNvbXBsZXRpb24gbWVzc2FnZSBpcyByZWNlaXZlZC4gVGhpcyBjYW4gb2NjdXIgbXVsdGlwbGUgdGltZXMgd2hlbiB1c2luZyBlLmcuIE9wZW5BSSBmdW5jdGlvbnNcbiAqIC0gYG9uRmluYWxgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgY2xvc2VkIHdpdGggdGhlIGZpbmFsIGNvbXBsZXRpb24gbWVzc2FnZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHByb2Nlc3MgYSBzdHJlYW0gb2YgbWVzc2FnZXMgYW5kIHBlcmZvcm0gc3BlY2lmaWMgYWN0aW9ucyBkdXJpbmcgdGhlIHN0cmVhbSdzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge0FJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9uc30gW2NhbGxiYWNrc10gLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHJldHVybiB7VHJhbnNmb3JtU3RyZWFtPHN0cmluZywgVWludDhBcnJheT59IEEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVuY29kZXMgaW5wdXQgbWVzc2FnZXMgYXMgVWludDhBcnJheSBhbmQgYWxsb3dzIHRoZSBleGVjdXRpb24gb2YgY3VzdG9tIGxvZ2ljIHRocm91Z2ggY2FsbGJhY2tzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjYWxsYmFja3MgPSB7XG4gKiAgIG9uU3RhcnQ6IGFzeW5jICgpID0+IGNvbnNvbGUubG9nKCdTdHJlYW0gc3RhcnRlZCcpLFxuICogICBvblRva2VuOiBhc3luYyAodG9rZW4pID0+IGNvbnNvbGUubG9nKGBUb2tlbjogJHt0b2tlbn1gKSxcbiAqICAgb25Db21wbGV0aW9uOiBhc3luYyAoY29tcGxldGlvbikgPT4gY29uc29sZS5sb2coYENvbXBsZXRpb246ICR7Y29tcGxldGlvbn1gKVxuICogICBvbkZpbmFsOiBhc3luYyAoKSA9PiBkYXRhLmNsb3NlKClcbiAqIH07XG4gKiBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgY2I6IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB8IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB8IHVuZGVmaW5lZCxcbik6IFRyYW5zZm9ybVN0cmVhbTxzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSAnJztcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KSBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG5cbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG5cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuXG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcblxuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKSBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIC8vIElmIGl0J3MgT3BlbkFJQ2FsbGJhY2tzLCBpdCBoYXMgYW4gZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyXG4gICAgICAvLyB3aWxsIGhhbmRsZSBjYWxsaW5nIG9uQ29tcGxldGUuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoXG4gIGNhbGxiYWNrczogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHwgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogY2FsbGJhY2tzIGlzIE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB7XG4gIHJldHVybiAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsJyBpbiBjYWxsYmFja3M7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdGF0ZWZ1bCBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIHRyaW1zIGxlYWRpbmcgd2hpdGVzcGFjZVxuICogZnJvbSB0aGUgaW5wdXQgdGV4dC4gVGhlIHRyaW1taW5nIG9ubHkgb2NjdXJzIG9uIHRoZSBmaXJzdCBpbnZvY2F0aW9uLCBlbnN1cmluZyB0aGF0XG4gKiBzdWJzZXF1ZW50IGNhbGxzIGRvIG5vdCBhbHRlciB0aGUgaW5wdXQgdGV4dC4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGluIHNjZW5hcmlvc1xuICogd2hlcmUgYSB0ZXh0IHN0cmVhbSBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIG9ubHkgdGhlIGluaXRpYWwgd2hpdGVzcGFjZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpOiBzdHJpbmd9IEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICogd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZCBpZiBpdCBpcyB0aGUgZmlyc3QgaW52b2NhdGlvbjsgb3RoZXJ3aXNlLCBpdCByZXR1cm5zIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHRyaW1TdGFydCA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gKiBjb25zdCBvdXRwdXQxID0gdHJpbVN0YXJ0KFwiICAgdGV4dFwiKTsgLy8gXCJ0ZXh0XCJcbiAqIGNvbnN0IG91dHB1dDIgPSB0cmltU3RhcnQoXCIgICB0ZXh0XCIpOyAvLyBcIiAgIHRleHRcIlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk6ICh0ZXh0OiBzdHJpbmcpID0+IHN0cmluZyB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcblxuICByZXR1cm4gKHRleHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFJlYWRhYmxlU3RyZWFtIGNyZWF0ZWQgZnJvbSB0aGUgcmVzcG9uc2UsIHBhcnNlZCBhbmQgaGFuZGxlZCB3aXRoIGN1c3RvbSBsb2dpYy5cbiAqIFRoZSBzdHJlYW0gZ29lcyB0aHJvdWdoIHR3byB0cmFuc2Zvcm1hdGlvbiBzdGFnZXMsIGZpcnN0IHBhcnNpbmcgdGhlIGV2ZW50cyBhbmQgdGhlblxuICogaW52b2tpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcy5cbiAqXG4gKiBGb3IgMnh4IEhUVFAgcmVzcG9uc2VzOlxuICogLSBUaGUgZnVuY3Rpb24gY29udGludWVzIHdpdGggc3RhbmRhcmQgc3RyZWFtIHByb2Nlc3NpbmcuXG4gKlxuICogRm9yIG5vbi0yeHggSFRUUCByZXNwb25zZXM6XG4gKiAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIGRlZmluZWQsIGl0IGFzeW5jaHJvbm91c2x5IGV4dHJhY3RzIGFuZCBkZWNvZGVzIHRoZSByZXNwb25zZSBib2R5LlxuICogLSBJdCB0aGVuIGNyZWF0ZXMgYSBjdXN0b20gUmVhZGFibGVTdHJlYW0gdG8gcHJvcGFnYXRlIGEgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZS5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJ9IGN1c3RvbVBhcnNlciAtIFRoZSBjdXN0b20gcGFyc2VyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnN9IGNhbGxiYWNrcyAtIFRoZSBjYWxsYmFja3MuXG4gKiBAcmV0dXJuIHtSZWFkYWJsZVN0cmVhbX0gVGhlIEFJU3RyZWFtLlxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSByZXNwb25zZSBpcyBub3QgT0suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBSVN0cmVhbShcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICBjdXN0b21QYXJzZXI/OiBBSVN0cmVhbVBhcnNlcixcbiAgY2FsbGJhY2tzPzogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5JykpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuXG4vLyBvdXRwdXRzIGxpbmVzIGxpa2Vcbi8vIDA6IGNodW5rXG4vLyAwOiBtb3JlIGNodW5rXG4vLyAxOiBhIGZjdCBjYWxsXG4vLyB6OiBhZGRlZCBkYXRhIGZyb20gRGF0YVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgUmVhZGFibGVTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBjbG9zZXMgdXBvbiBjcmVhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBhcyBhIGZhbGxiYWNrIGZvciBjcmVhdGluZyBhIFJlYWRhYmxlU3RyZWFtIHdoZW4gdGhlIHJlc3BvbnNlIGJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWQsXG4gKiBlbnN1cmluZyB0aGF0IHRoZSBzdWJzZXF1ZW50IHBpcGVsaW5lIHByb2Nlc3NpbmcgZG9lc24ndCBmYWlsIGR1ZSB0byBhIGxhY2sgb2YgYSBzdHJlYW0uXG4gKlxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfSBBbiBlbXB0eSBhbmQgY2xvc2VkIFJlYWRhYmxlU3RyZWFtIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgUmVhZGFibGVTdHJlYW0uZnJvbShhc3luY0l0ZXJhYmxlKSwgd2hpY2ggaXNuJ3QgZG9jdW1lbnRlZCBpbiBNRE4gYW5kIGlzbid0IGltcGxlbWVudGVkIGluIG5vZGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvY29tbWl0LzhkN2EwYmYyNmViMmNjMjNlODg0ZGRiYWFjN2MxZGE0YjkxY2YyYmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGU8VD4oaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VD4pIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW08VD4oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgYXdhaXQgaXQucmV0dXJuPy4ocmVhc29uKTtcbiAgICB9LFxuICB9KTtcbn1cbiIsImltcG9ydCB7IEpTT05WYWx1ZSwgZm9ybWF0U3RyZWFtUGFydCB9IGZyb20gJ0BhaS1zZGsvdWktdXRpbHMnO1xuXG4vKipcbiAqIEEgc3RyZWFtIHdyYXBwZXIgdG8gc2VuZCBjdXN0b20gSlNPTi1lbmNvZGVkIGRhdGEgYmFjayB0byB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtRGF0YSB7XG4gIHByaXZhdGUgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIHByaXZhdGUgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuXG4gIHByaXZhdGUgaXNDbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyBjb250cm9sbGVyID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAgICAgICAvLyBTZXQgYSB0aW1lb3V0IHRvIHNob3cgYSB3YXJuaW5nIGlmIHRoZSBzdHJlYW0gaXMgbm90IGNsb3NlZCB3aXRoaW4gMyBzZWNvbmRzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHNlbGYud2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1RoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgPycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIC8vIE5vLW9wOiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwgb24gcHVsbFxuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbGxlci5jbG9zZSgpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuXG4gICAgLy8gQ2xlYXIgdGhlIHdhcm5pbmcgdGltZW91dCBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZFxuICAgIGlmICh0aGlzLndhcm5pbmdUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53YXJuaW5nVGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKHZhbHVlOiBKU09OVmFsdWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ2RhdGEnLCBbdmFsdWVdKSksXG4gICAgKTtcbiAgfVxuXG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlOiBKU09OVmFsdWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCBbdmFsdWVdKSksXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgVHJhbnNmb3JtU3RyZWFtIGZvciBMTE1zIHRoYXQgZG8gbm90IGhhdmUgdGhlaXIgb3duIHRyYW5zZm9ybSBzdHJlYW0gaGFuZGxlcnMgbWFuYWdpbmcgZW5jb2RpbmcgKGUuZy4gT3BlbkFJU3RyZWFtIGhhcyBvbmUgZm9yIGZ1bmN0aW9uIGNhbGwgaGFuZGxpbmcpLlxuICogVGhpcyBhc3N1bWVzIGV2ZXJ5IGNodW5rIGlzIGEgJ3RleHQnIGNodW5rLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBtZXNzYWdlKSkpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbkBkZXByZWNhdGVkIFVzZSBgU3RyZWFtRGF0YWAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNsYXNzIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhIGV4dGVuZHMgU3RyZWFtRGF0YSB7fVxuIiwiaW1wb3J0IHtcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgRnVuY3Rpb25DYWxsLFxuICBKU09OVmFsdWUsXG4gIFRvb2xDYWxsLFxuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG59IGZyb20gJ0BhaS1zZGsvdWktdXRpbHMnO1xuaW1wb3J0IHtcbiAgQUlTdHJlYW0sXG4gIEZ1bmN0aW9uQ2FsbFBheWxvYWQsXG4gIFRvb2xDYWxsUGF5bG9hZCxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyLFxuICB0eXBlIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyxcbn0gZnJvbSAnLi9haS1zdHJlYW0nO1xuaW1wb3J0IHsgQXp1cmVDaGF0Q29tcGxldGlvbnMgfSBmcm9tICcuL2F6dXJlLW9wZW5haS10eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIgfSBmcm9tICcuL3N0cmVhbS1kYXRhJztcblxuZXhwb3J0IHR5cGUgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzID0gQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zICYge1xuICAvKipcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICBzdHJlYW06IHRydWUsXG4gICAqICAgbWVzc2FnZXMsXG4gICAqICAgZnVuY3Rpb25zLFxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zdCBzdHJlYW0gPSBPcGVuQUlTdHJlYW0ocmVzcG9uc2UsIHtcbiAgICogICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw6IGFzeW5jIChmdW5jdGlvbkNhbGxQYXlsb2FkLCBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlcykgPT4ge1xuICAgKiAgICAgLy8gLi4uIHJ1biB5b3VyIGN1c3RvbSBsb2dpYyBoZXJlXG4gICAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBteUZ1bmN0aW9uKGZ1bmN0aW9uQ2FsbFBheWxvYWQpXG4gICAqXG4gICAqICAgICAvLyBBc2sgZm9yIGFub3RoZXIgY29tcGxldGlvbiwgb3IgcmV0dXJuIGEgc3RyaW5nIHRvIHNlbmQgdG8gdGhlIGNsaWVudCBhcyBhbiBhc3Npc3RhbnQgbWVzc2FnZS5cbiAgICogICAgIHJldHVybiBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMDYxMycsXG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZWxldmFudCBcImFzc2lzdGFudFwiIGFuZCBcImZ1bmN0aW9uXCIgY2FsbCBtZXNzYWdlc1xuICAgKiAgICAgICBtZXNzYWdlczogWy4uLm1lc3NhZ2VzLCAuLi5jcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlcyhyZXN1bHQpXSxcbiAgICogICAgICAgZnVuY3Rpb25zLFxuICAgKiAgICAgfSlcbiAgICogICB9XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsPzogKFxuICAgIGZ1bmN0aW9uQ2FsbFBheWxvYWQ6IEZ1bmN0aW9uQ2FsbFBheWxvYWQsXG4gICAgY3JlYXRlRnVuY3Rpb25DYWxsTWVzc2FnZXM6IChcbiAgICAgIGZ1bmN0aW9uQ2FsbFJlc3VsdDogSlNPTlZhbHVlLFxuICAgICkgPT4gQ3JlYXRlTWVzc2FnZVtdLFxuICApID0+IFByb21pc2U8XG4gICAgUmVzcG9uc2UgfCB1bmRlZmluZWQgfCB2b2lkIHwgc3RyaW5nIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzXG4gID47XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTExMDYnLCAvLyBvciBncHQtNC0xMTA2LXByZXZpZXdcbiAgICogICBzdHJlYW06IHRydWUsXG4gICAqICAgbWVzc2FnZXMsXG4gICAqICAgdG9vbHMsXG4gICAqICAgdG9vbF9jaG9pY2U6IFwiYXV0b1wiLCAvLyBhdXRvIGlzIGRlZmF1bHQsIGJ1dCB3ZSdsbCBiZSBleHBsaWNpdFxuICAgKiB9KVxuICAgKlxuICAgKiBjb25zdCBzdHJlYW0gPSBPcGVuQUlTdHJlYW0ocmVzcG9uc2UsIHtcbiAgICogICBleHBlcmltZW50YWxfb25Ub29sQ2FsbDogYXN5bmMgKHRvb2xDYWxsUGF5bG9hZCwgYXBwZW5kVG9vbENhbGxNZXNzYWdlcykgPT4ge1xuICAgKiAgICBsZXQgbWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9IFtdXG4gICAqICAgIC8vICAgVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgdG9vbCBjYWxscywgc28gd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlbVxuICAgKiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24odG9vbC5mdW5jdGlvbilcbiAgICogICAgLy8gQXBwZW5kIHRoZSByZWxldmFudCBcImFzc2lzdGFudFwiIGFuZCBcInRvb2xcIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICBhcHBlbmRUb29sQ2FsbE1lc3NhZ2Uoe3Rvb2xfY2FsbF9pZDp0b29sLmlkLCBmdW5jdGlvbl9uYW1lOnRvb2wuZnVuY3Rpb24ubmFtZSwgdG9vbF9jYWxsX3Jlc3VsdDpyZXN1bHR9KVxuICAgKiAgICB9XG4gICAqICAgICAvLyBBc2sgZm9yIGFub3RoZXIgY29tcGxldGlvbiwgb3IgcmV0dXJuIGEgc3RyaW5nIHRvIHNlbmQgdG8gdGhlIGNsaWVudCBhcyBhbiBhc3Npc3RhbnQgbWVzc2FnZS5cbiAgICogICAgIHJldHVybiBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgICAgICBzdHJlYW06IHRydWUsXG4gICAqICAgICAgIC8vIEFwcGVuZCB0aGUgcmVzdWx0cyBtZXNzYWdlcywgY2FsbGluZyBhcHBlbmRUb29sQ2FsbE1lc3NhZ2Ugd2l0aG91dFxuICAgKiAgICAgICAvLyBhbnkgYXJndW1lbnRzIHdpbGwganN1dCByZXR1cm4gdGhlIGFjY3VtdWxhdGVkIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmFwcGVuZFRvb2xDYWxsTWVzc2FnZSgpXSxcbiAgICogICAgICAgdG9vbHMsXG4gICAqICAgICAgICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbD86IChcbiAgICB0b29sQ2FsbFBheWxvYWQ6IFRvb2xDYWxsUGF5bG9hZCxcbiAgICBhcHBlbmRUb29sQ2FsbE1lc3NhZ2U6IChyZXN1bHQ/OiB7XG4gICAgICB0b29sX2NhbGxfaWQ6IHN0cmluZztcbiAgICAgIGZ1bmN0aW9uX25hbWU6IHN0cmluZztcbiAgICAgIHRvb2xfY2FsbF9yZXN1bHQ6IEpTT05WYWx1ZTtcbiAgICB9KSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMjgtTDQwXG5pbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIGlkOiBzdHJpbmc7XG4gIGNob2ljZXM6IEFycmF5PENoYXRDb21wbGV0aW9uQ2h1bmtDaG9pY2U+O1xuICBjcmVhdGVkOiBudW1iZXI7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIG9iamVjdDogc3RyaW5nO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvMDdiMzUwNGUxYzQwZmQ5MjlmNGFhZTE2NTFiODNhZmMxOWUzYmFmOC9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMjTDQzLUw0OVxuLy8gVXBkYXRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvZjEwYzc1N2Q4MzFkOTA0MDdiYTQ3YjQ2NTlkOWNkMzRiMWEzNWIxZFxuLy8gVXBkYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC84NGI0MzI4MDA4OWVhY2RmMThmMTcxNzIzNTkxODU2ODExYmVkZGNlXG5pbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DaHVua0Nob2ljZSB7XG4gIGRlbHRhOiBDaG9pY2VEZWx0YTtcbiAgZmluaXNoX3JlYXNvbjpcbiAgICB8ICdzdG9wJ1xuICAgIHwgJ2xlbmd0aCdcbiAgICB8ICd0b29sX2NhbGxzJ1xuICAgIHwgJ2NvbnRlbnRfZmlsdGVyJ1xuICAgIHwgJ2Z1bmN0aW9uX2NhbGwnXG4gICAgfCBudWxsO1xuICBpbmRleDogbnVtYmVyO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvMDdiMzUwNGUxYzQwZmQ5MjlmNGFhZTE2NTFiODNhZmMxOWUzYmFmOC9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMjTDEyMy1MMTM5XG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaG9pY2VEZWx0YSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGNodW5rIG1lc3NhZ2UuXG4gICAqL1xuICBjb250ZW50Pzogc3RyaW5nIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgYW5kIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZVxuICAgKiBtb2RlbC5cbiAgICovXG4gIGZ1bmN0aW9uX2NhbGw/OiBGdW5jdGlvbkNhbGw7XG5cbiAgLyoqXG4gICAqIFRoZSByb2xlIG9mIHRoZSBhdXRob3Igb2YgdGhpcyBtZXNzYWdlLlxuICAgKi9cbiAgcm9sZT86ICdzeXN0ZW0nIHwgJ3VzZXInIHwgJ2Fzc2lzdGFudCcgfCAndG9vbCc7XG5cbiAgdG9vbF9jYWxscz86IEFycmF5PERlbHRhVG9vbENhbGw+O1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBEZWx0YVRvb2xDYWxsIHtcbiAgaW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSB0b29sIGNhbGwuXG4gICAqL1xuICBpZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgdGhlIG1vZGVsIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uPzogVG9vbENhbGxGdW5jdGlvbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIHRvb2wuIEN1cnJlbnRseSwgb25seSBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIHR5cGU/OiAnZnVuY3Rpb24nO1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBUb29sQ2FsbEZ1bmN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBhcmd1bWVudHMgdG8gY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCwgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpbiBKU09OXG4gICAqIGZvcm1hdC4gTm90ZSB0aGF0IHRoZSBtb2RlbCBkb2VzIG5vdCBhbHdheXMgZ2VuZXJhdGUgdmFsaWQgSlNPTiwgYW5kIG1heVxuICAgKiBoYWxsdWNpbmF0ZSBwYXJhbWV0ZXJzIG5vdCBkZWZpbmVkIGJ5IHlvdXIgZnVuY3Rpb24gc2NoZW1hLiBWYWxpZGF0ZSB0aGVcbiAgICogYXJndW1lbnRzIGluIHlvdXIgY29kZSBiZWZvcmUgY2FsbGluZyB5b3VyIGZ1bmN0aW9uLlxuICAgKi9cbiAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzNlYzQzZWU3OTBhMmViNmEwY2NkZDVmMjVmYWEyMzI1MWIwZjliOGUvc3JjL3Jlc291cmNlcy9jb21wbGV0aW9ucy50cyNMMjhDMS1MNjRDMVxuICogQ29tcGxldGlvbnMgQVBJLiBTdHJlYW1lZCBhbmQgbm9uLXN0cmVhbWVkIHJlc3BvbnNlcyBhcmUgdGhlIHNhbWUuXG4gKi9cbmludGVyZmFjZSBDb21wbGV0aW9uIHtcbiAgLyoqXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjb21wbGV0aW9uLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgY29tcGxldGlvbiBjaG9pY2VzIHRoZSBtb2RlbCBnZW5lcmF0ZWQgZm9yIHRoZSBpbnB1dCBwcm9tcHQuXG4gICAqL1xuICBjaG9pY2VzOiBBcnJheTxDb21wbGV0aW9uQ2hvaWNlPjtcblxuICAvKipcbiAgICogVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGNvbXBsZXRpb24gd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlbCB1c2VkIGZvciBjb21wbGV0aW9uLlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0eXBlLCB3aGljaCBpcyBhbHdheXMgXCJ0ZXh0X2NvbXBsZXRpb25cIlxuICAgKi9cbiAgb2JqZWN0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuICB1c2FnZT86IENvbXBsZXRpb25Vc2FnZTtcbn1cblxuaW50ZXJmYWNlIENvbXBsZXRpb25DaG9pY2Uge1xuICAvKipcbiAgICogVGhlIHJlYXNvbiB0aGUgbW9kZWwgc3RvcHBlZCBnZW5lcmF0aW5nIHRva2Vucy4gVGhpcyB3aWxsIGJlIGBzdG9wYCBpZiB0aGUgbW9kZWxcbiAgICogaGl0IGEgbmF0dXJhbCBzdG9wIHBvaW50IG9yIGEgcHJvdmlkZWQgc3RvcCBzZXF1ZW5jZSwgb3IgYGxlbmd0aGAgaWYgdGhlIG1heGltdW1cbiAgICogbnVtYmVyIG9mIHRva2VucyBzcGVjaWZpZWQgaW4gdGhlIHJlcXVlc3Qgd2FzIHJlYWNoZWQuXG4gICAqL1xuICBmaW5pc2hfcmVhc29uOiAnc3RvcCcgfCAnbGVuZ3RoJyB8ICdjb250ZW50X2ZpbHRlcic7XG5cbiAgaW5kZXg6IG51bWJlcjtcblxuICAvLyBlZGl0ZWQ6IFJlbW92ZWQgQ29tcGxldGlvbkNob2ljZS5sb2dQcm9icyBhbmQgcmVwbGFjZWQgd2l0aCBhbnlcbiAgbG9ncHJvYnM6IGFueSB8IG51bGw7XG5cbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25Vc2FnZSB7XG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cblxuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2VuZXJhdGVkIGNvbXBsZXRpb24uXG4gICAqL1xuICBjb21wbGV0aW9uX3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRfdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCBpbiB0aGUgcmVxdWVzdCAocHJvbXB0ICsgY29tcGxldGlvbikuXG4gICAqL1xuICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcGFyc2VyIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIHRoZSBPcGVuQUkgc3RyZWFtIGRhdGEuXG4gKiBUaGUgcGFyc2VyIGV4dHJhY3RzIGFuZCB0cmltcyB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgSlNPTiBkYXRhLiBUaGlzIHBhcnNlclxuICogY2FuIGhhbmRsZSBkYXRhIGZvciBjaGF0IG9yIGNvbXBsZXRpb24gbW9kZWxzLlxuICpcbiAqIEByZXR1cm4geyhkYXRhOiBzdHJpbmcpID0+IHN0cmluZyB8IHZvaWR8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH19XG4gKiBBIHBhcnNlciBmdW5jdGlvbiB0aGF0IHRha2VzIGEgSlNPTiBzdHJpbmcgYXMgaW5wdXQgYW5kIHJldHVybnMgdGhlIGV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQsXG4gKiBhIGNvbXBsZXggb2JqZWN0IHdpdGggaXNUZXh0OiBmYWxzZSBmb3IgZnVuY3Rpb24vdG9vbCBjYWxscywgb3Igbm90aGluZy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKTogKFxuICBkYXRhOiBzdHJpbmcsXG4pID0+IHN0cmluZyB8IHZvaWQgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9IHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiBkYXRhID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSBhcyBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyk7XG59XG5cbi8qKlxuICogUmVhZHMgY2h1bmtzIGZyb20gT3BlbkFJJ3MgbmV3IFN0cmVhbWFibGUgaW50ZXJmYWNlLCB3aGljaCBpcyBlc3NlbnRpYWxseVxuICogdGhlIHNhbWUgYXMgdGhlIG9sZCBSZXNwb25zZSBib2R5IGludGVyZmFjZSB3aXRoIGFuIGluY2x1ZGVkIFNTRSBwYXJzZXJcbiAqIGRvaW5nIHRoZSBwYXJzaW5nIGZvciB1cy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtOiBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG5cbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgLy8gY29udmVydCBjaHVuayBpZiBpdCBpcyBhbiBBenVyZSBjaGF0IGNvbXBsZXRpb24uIEF6dXJlIGRvZXMgbm90IGV4cG9zZSBhbGxcbiAgICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBpbnRlcmZhY2VzLCBhbmQgYWxzbyB1c2VzIGNhbWVsQ2FzZSBpbnN0ZWFkIG9mIHNuYWtlX2Nhc2VcbiAgICBpZiAoJ3Byb21wdEZpbHRlclJlc3VsdHMnIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiAoY2h1bmsgYXMgYW55KS5vYmplY3QsIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogKGNodW5rIGFzIGFueSkubW9kZWwsIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcChjaG9pY2UgPT4gKHtcbiAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgY29udGVudDogY2hvaWNlLmRlbHRhPy5jb250ZW50LFxuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hvaWNlLmRlbHRhPy5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICByb2xlOiBjaG9pY2UuZGVsdGE/LnJvbGUgYXMgYW55LFxuICAgICAgICAgICAgdG9vbF9jYWxsczogY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lmxlbmd0aFxuICAgICAgICAgICAgICA/IGNob2ljZS5kZWx0YT8udG9vbENhbGxzPy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZSxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uIGFzIGFueSxcbiAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4LFxuICAgICAgICB9KSksXG4gICAgICB9IHNhdGlzZmllcyBDaGF0Q29tcGxldGlvbkNodW5rO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcblxuICAgIGlmICh0ZXh0KSB5aWVsZCB0ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCk6IChcbiAgY2h1bms6IE9wZW5BSVN0cmVhbVJldHVyblR5cGVzLFxuKSA9PiBzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9IHwgdm9pZCB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjogYm9vbGVhbjtcbiAgcmV0dXJuIGpzb24gPT4ge1xuICAgIGlmIChpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbi5jaG9pY2VzWzBdPy5kZWx0YTtcbiAgICAgIGlmIChkZWx0YS5mdW5jdGlvbl9jYWxsPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8ubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYHtcInRvb2xfY2FsbHNcIjpbIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHt0b29sQ2FsbC5mdW5jdGlvbj8ubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEuZnVuY3Rpb25fY2FsbD8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKGRlbHRhLnRvb2xfY2FsbHM/LlswXT8uZnVuY3Rpb24/LmFyZ3VtZW50cyksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAgKGpzb24uY2hvaWNlc1swXT8uZmluaXNoX3JlYXNvbiA9PT0gJ2Z1bmN0aW9uX2NhbGwnIHx8XG4gICAgICAgICAganNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnc3RvcCcpXG4gICAgICApIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7IC8vIFJlc2V0IHRoZSBmbGFnXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fScsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAganNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAndG9vbF9jYWxscydcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudFxuICAgICAgICA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgIDogaXNDb21wbGV0aW9uKGpzb24pXG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLnRleHRcbiAgICAgICAgOiAnJyxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rOiBzdHJpbmcpIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVua1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgLy8gUmVwbGFjZSBiYWNrc2xhc2hlcyBmaXJzdCB0byBwcmV2ZW50IGRvdWJsZSBlc2NhcGluZ1xuICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKSAvLyBFc2NhcGUgc2xhc2hlc1xuICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSAvLyBFc2NhcGUgZG91YmxlIHF1b3Rlc1xuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAvLyBFc2NhcGUgbmV3IGxpbmVzXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpIC8vIEVzY2FwZSBjYXJyaWFnZSByZXR1cm5zXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpIC8vIEVzY2FwZSB0YWJzXG4gICAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpOyAvLyBFc2NhcGUgZm9ybSBmZWVkc1xuXG4gICAgcmV0dXJuIGAke2VzY2FwZWRQYXJ0aWFsSnNvbn1gO1xuICB9XG59XG5cbmNvbnN0IF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gICdpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXMnLFxuKTtcblxudHlwZSBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMgPVxuICB8IEFzeW5jSXRlcmFibGU8Q2hhdENvbXBsZXRpb25DaHVuaz5cbiAgfCBBc3luY0l0ZXJhYmxlPENvbXBsZXRpb24+XG4gIHwgQXN5bmNJdGVyYWJsZTxBenVyZUNoYXRDb21wbGV0aW9ucz47XG5cbnR5cGUgRXh0cmFjdFR5cGU8VD4gPSBUIGV4dGVuZHMgQXN5bmNJdGVyYWJsZTxpbmZlciBVPiA/IFUgOiBuZXZlcjtcblxudHlwZSBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIEV4dHJhY3RUeXBlPEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcz47XG5cbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhcbiAgZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pOiBkYXRhIGlzIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ2RlbHRhJyBpbiBkYXRhLmNob2ljZXNbMF1cbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGE6IE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTogZGF0YSBpcyBDb21wbGV0aW9uIHtcbiAgcmV0dXJuIChcbiAgICAnY2hvaWNlcycgaW4gZGF0YSAmJlxuICAgIGRhdGEuY2hvaWNlcyAmJlxuICAgIGRhdGEuY2hvaWNlc1swXSAmJlxuICAgICd0ZXh0JyBpbiBkYXRhLmNob2ljZXNbMF1cbiAgKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIFtPcGVuQUkgcHJvdmlkZXJdKGh0dHBzOi8vc2RrLnZlcmNlbC5haS9wcm92aWRlcnMvYWktc2RrLXByb3ZpZGVycy9vcGVuYWkpIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPcGVuQUlTdHJlYW0oXG4gIHJlczogUmVzcG9uc2UgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4gIGNhbGxiYWNrcz86IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyxcbik6IFJlYWRhYmxlU3RyZWFtIHtcbiAgLy8gQW5ub3RhdGUgdGhlIGludGVybmFsIGBtZXNzYWdlc2AgcHJvcGVydHkgZm9yIHJlY3Vyc2l2ZSBmdW5jdGlvbiBjYWxsc1xuICBjb25zdCBjYjpcbiAgICB8IHVuZGVmaW5lZFxuICAgIHwgKE9wZW5BSVN0cmVhbUNhbGxiYWNrcyAmIHtcbiAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdPzogQ3JlYXRlTWVzc2FnZVtdO1xuICAgICAgfSkgPSBjYWxsYmFja3M7XG5cbiAgbGV0IHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT47XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIGNiPy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2I/LmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICBvbkZpbmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKFxuICBjYWxsYmFja3M6IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyAmIHtcbiAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gIH0sXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9ICcnO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gJyc7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcblxuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9XG4gICAgY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuXG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG5cbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPVxuICAgICAgICBpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8XG4gICAgICAgICAgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuXG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyZWFtIGFzIG5vcm1hbFxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgbWVzc2FnZSkpLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaXNGaXJzdENodW5rICYmXG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmXG4gICAgICAgICAgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHxcbiAgICAgICAgICAgIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgbWVzc2FnZSB0byB0aGUgbGlzdFxuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlOlxuICAgICAgICAgICAgfCBSZXNwb25zZVxuICAgICAgICAgICAgfCB1bmRlZmluZWRcbiAgICAgICAgICAgIHwgdm9pZFxuICAgICAgICAgICAgfCBzdHJpbmdcbiAgICAgICAgICAgIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzXG4gICAgICAgICAgICB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAvLyBUaGlzIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2hlY2sgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYnV0IFRTIGNvbXBsYWluc1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyB1c2luZyB0aGUgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIGNhbGxiYWNrLCB0aGV5IHNob3VsZCBub3QgYmUgdXNpbmcgdG9vbHNcbiAgICAgICAgICAgIC8vIGlmIHBheWxvYWQuZnVuY3Rpb25fY2FsbCBpcyBub3QgZGVmaW5lZCBieSB0aW1lIHdlIGdldCBoZXJlIHdlIG11c3QgaGF2ZSBnb3R0ZW4gYSB0b29sIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHVzZXIgaGFkIGRlZmluZWQgZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzOiBUb29sQ2FsbFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID1cbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXF1ZXN0IGFuZCByZXN1bHQgbWVzc2FnZXMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4uKHJlc3BvbnNlSW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGM6IFRvb2xDYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgZGlkbid0IGRvIGFueXRoaW5nIHdpdGggdGhlIGZ1bmN0aW9uIGNhbGwgb24gdGhlIHNlcnZlciBhbmQgd2FudHNcbiAgICAgICAgICAgIC8vIHRvIGVpdGhlciBkbyBub3RoaW5nIG9yIHJ1biBpdCBvbiB0aGUgY2xpZW50XG4gICAgICAgICAgICAvLyBzbyB3ZSBqdXN0IHJldHVybiB0aGUgZnVuY3Rpb24gY2FsbCBhcyBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyAnZnVuY3Rpb25fY2FsbCcgOiAndG9vbF9jYWxscycsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgcmV0dXJuZWQgYSBzdHJpbmcsIHNvIHdlIGp1c3QgcmV0dXJuIGl0IGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIGZ1bmN0aW9uUmVzcG9uc2UpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5OlxuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIG9uU3RhcnQgb3Igb25Db21wbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgIC8vIHNvIHdlIHJlbW92ZSB0aGVtIGZyb20gdGhlIGNhbGxiYWNrc1xuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL2FpL2lzc3Vlcy8zNTFcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uRmluYWwgdG8gYmUgY2FsbGVkIHRoZSBfbGFzdF8gdGltZVxuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICB9IGFzIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyk7XG5cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG4iLCJleHBvcnQgY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcigndWkuc3RyZWFtYWJsZS52YWx1ZScpO1xuZXhwb3J0IGNvbnN0IERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FID0gMTUgKiAxMDAwO1xuIiwiaW1wb3J0IHtcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgTGFuZ3VhZ2VNb2RlbFYxLFxuICBOb1N1Y2hUb29sRXJyb3IsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0JztcbmltcG9ydCB7IGdldFZhbGlkYXRlZFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0JztcbmltcG9ydCB7IHByZXBhcmVDYWxsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3Byb21wdCc7XG5pbXBvcnQgeyBDYWxsV2FybmluZywgQ29yZVRvb2xDaG9pY2UsIEZpbmlzaFJlYXNvbiB9IGZyb20gJy4uLy4uL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHtcbiAgQ29tcGxldGlvblRva2VuVXNhZ2UsXG4gIGNhbGN1bGF0ZUNvbXBsZXRpb25Ub2tlblVzYWdlLFxufSBmcm9tICcuLi8uLi9jb3JlL3R5cGVzL3Rva2VuLXVzYWdlJztcbmltcG9ydCB7IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYnO1xuaW1wb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJIH0gZnJvbSAnLi4vc3RyZWFtYWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uL3V0aWxzJztcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xuXG50eXBlIFJlbmRlcmVyPFQgZXh0ZW5kcyBBcnJheTxhbnk+PiA9IChcbiAgLi4uYXJnczogVFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxudHlwZSBSZW5kZXJUb29sPFBBUkFNRVRFUlMgZXh0ZW5kcyB6LlpvZFR5cGVBbnkgPSBhbnk+ID0ge1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcGFyYW1ldGVyczogUEFSQU1FVEVSUztcbiAgZ2VuZXJhdGU/OiBSZW5kZXJlcjxcbiAgICBbXG4gICAgICB6LmluZmVyPFBBUkFNRVRFUlM+LFxuICAgICAge1xuICAgICAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgICAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgICB9LFxuICAgIF1cbiAgPjtcbn07XG5cbnR5cGUgUmVuZGVyVGV4dCA9IFJlbmRlcmVyPFxuICBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAgICovXG4gICAgICBkZWx0YTogc3RyaW5nO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAgICovXG4gICAgICBkb25lOiBib29sZWFuO1xuICAgIH0sXG4gIF1cbj47XG5cbnR5cGUgUmVuZGVyUmVzdWx0ID0ge1xuICB2YWx1ZTogUmVhY3ROb2RlO1xufSAmIEF3YWl0ZWQ8UmV0dXJuVHlwZTxMYW5ndWFnZU1vZGVsVjFbJ2RvU3RyZWFtJ10+PjtcblxuY29uc3QgZGVmYXVsdFRleHRSZW5kZXJlcjogUmVuZGVyVGV4dCA9ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT5cbiAgY29udGVudDtcblxuLyoqXG4gKiBgc3RyZWFtVUlgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBMTE1zLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVUk8XG4gIFRPT0xTIGV4dGVuZHMgeyBbbmFtZTogc3RyaW5nXTogei5ab2RUeXBlQW55IH0gPSB7fSxcbj4oe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGluaXRpYWwsXG4gIHRleHQsXG4gIG9uRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufTogQ2FsbFNldHRpbmdzICZcbiAgUHJvbXB0ICYge1xuICAgIC8qKlxuICAgICAqIFRoZSBsYW5ndWFnZSBtb2RlbCB0byB1c2UuXG4gICAgICovXG4gICAgbW9kZWw6IExhbmd1YWdlTW9kZWxWMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29scyB0aGF0IHRoZSBtb2RlbCBjYW4gY2FsbC4gVGhlIG1vZGVsIG5lZWRzIHRvIHN1cHBvcnQgY2FsbGluZyB0b29scy5cbiAgICAgKi9cbiAgICB0b29scz86IHtcbiAgICAgIFtuYW1lIGluIGtleW9mIFRPT0xTXTogUmVuZGVyVG9vbDxUT09MU1tuYW1lXT47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b29sIGNob2ljZSBzdHJhdGVneS4gRGVmYXVsdDogJ2F1dG8nLlxuICAgICAqL1xuICAgIHRvb2xDaG9pY2U/OiBDb3JlVG9vbENob2ljZTxUT09MUz47XG5cbiAgICB0ZXh0PzogUmVuZGVyVGV4dDtcbiAgICBpbml0aWFsPzogUmVhY3ROb2RlO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIExMTSByZXNwb25zZSBhbmQgdGhlIGZpbmFsIG9iamVjdCB2YWxpZGF0aW9uIGFyZSBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBvbkZpbmlzaD86IChldmVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcmVhc29uIHdoeSB0aGUgZ2VuZXJhdGlvbiBmaW5pc2hlZC5cbiAgICAgICAqL1xuICAgICAgZmluaXNoUmVhc29uOiBGaW5pc2hSZWFzb247XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b2tlbiB1c2FnZSBvZiB0aGUgZ2VuZXJhdGVkIHJlc3BvbnNlLlxuICAgICAgICovXG4gICAgICB1c2FnZTogQ29tcGxldGlvblRva2VuVXNhZ2U7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmaW5hbCB1aSBub2RlIHRoYXQgd2FzIGdlbmVyYXRlZC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IFJlYWN0Tm9kZTtcbiAgICAgIC8qKlxuICAgICAgICogV2FybmluZ3MgZnJvbSB0aGUgbW9kZWwgcHJvdmlkZXIgKGUuZy4gdW5zdXBwb3J0ZWQgc2V0dGluZ3MpXG4gICAgICAgKi9cbiAgICAgIHdhcm5pbmdzPzogQ2FsbFdhcm5pbmdbXTtcbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9uYWwgcmF3IHJlc3BvbnNlIGRhdGEuXG4gICAgICAgKi9cbiAgICAgIHJhd1Jlc3BvbnNlPzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzcG9uc2UgaGVhZGVycy5cbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgfTtcbiAgICB9KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgfSk6IFByb21pc2U8UmVuZGVyUmVzdWx0PiB7XG4gIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBlcnJvcnMgYWZ0ZXIgdGhlIGV4cGVyaW1lbnRhbCBwaGFzZS5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYG1vZGVsYCBjYW5ub3QgYmUgYSBzdHJpbmcgaW4gYHN0cmVhbVVJYC4gVXNlIHRoZSBhY3R1YWwgbW9kZWwgaW5zdGFuY2UgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdmdW5jdGlvbnMnIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2BmdW5jdGlvbnNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYHN0cmVhbVVJYCwgdXNlIGB0b29sc2AgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdwcm92aWRlcicgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYHByb3ZpZGVyYCBpcyBubyBsb25nZXIgbmVlZGVkIGluIGBzdHJlYW1VSWAuIFVzZSBgbW9kZWxgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuICAgICAgaWYgKCdyZW5kZXInIGluIHRvb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUb29sIGRlZmluaXRpb24gaW4gYHN0cmVhbVVJYCBzaG91bGQgbm90IGhhdmUgYHJlbmRlcmAgcHJvcGVydHkuIFVzZSBgZ2VuZXJhdGVgIGluc3RlYWQuIEZvdW5kIGluIHRvb2w6ICcgK1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHRSZW5kZXIgPSB0ZXh0IHx8IGRlZmF1bHRUZXh0UmVuZGVyZXI7XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBbcGF5bG9hZDogYW55XSB8IFtwYXlsb2FkOiBhbnksIG9wdGlvbnM6IGFueV0sXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICAgIGxhc3RDYWxsID0gZmFsc2UsXG4gICkge1xuICAgIGlmICghcmVuZGVyZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTx2b2lkPigpO1xuXG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICBmaW5pc2hlZCA9IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVzb2x2YWJsZS5wcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWQgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSByZW5kZXJlciguLi5hcmdzKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgfHxcbiAgICAgICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd0aGVuJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCAodmFsdWUgYXMgUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+KTtcblxuICAgICAgaWYgKGxhc3RDYWxsKSB7XG4gICAgICAgIHJlcy5kb25lKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLnVwZGF0ZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIGlmIChsYXN0Q2FsbCAmJiBkb25lKSB7XG4gICAgICAgICAgcmVzLmRvbmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgR2VuZXJhdG9yPFJlYWN0LlJlYWN0Tm9kZSwgUmVhY3QuUmVhY3ROb2RlLCB2b2lkPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0Lm5leHQoKTtcbiAgICAgICAgaWYgKGxhc3RDYWxsICYmIGRvbmUpIHtcbiAgICAgICAgICByZXMuZG9uZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsYXN0Q2FsbCkge1xuICAgICAgICByZXMuZG9uZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShhc3luYyAoKSA9PlxuICAgIG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSksXG4gICAgICB9LFxuICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICB9KSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgaGVhZGVycyxcbiAgICB9KSxcbiAgKTtcblxuICBjb25zdCBbc3RyZWFtLCBmb3JrZWRTdHJlYW1dID0gcmVzdWx0LnN0cmVhbS50ZWUoKTtcblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25zdW1lIHRoZSBmb3JrZWQgc3RyZWFtIGFzeW5jaG9ub3VzbHkuXG5cbiAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICBsZXQgaGFzVG9vbENhbGwgPSBmYWxzZTtcblxuICAgICAgY29uc3QgcmVhZGVyID0gZm9ya2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3RleHQtZGVsdGEnOiB7XG4gICAgICAgICAgICBjb250ZW50ICs9IHZhbHVlLnRleHREZWx0YTtcbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgW3sgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiB2YWx1ZS50ZXh0RGVsdGEgfV0sXG4gICAgICAgICAgICAgIHRleHRSZW5kZXIsXG4gICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbC1kZWx0YSc6IHtcbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdmFsdWUudG9vbE5hbWUgYXMga2V5b2YgVE9PTFMgJiBzdHJpbmc7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sTmFtZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICghdG9vbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzVG9vbENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB0b29sLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgdG9vbC5nZW5lcmF0ZSxcbiAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlLmVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6IHtcbiAgICAgICAgICAgIG9uRmluaXNoPy4oe1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZUNvbXBsZXRpb25Ub2tlblVzYWdlKHZhbHVlLnVzYWdlKSxcbiAgICAgICAgICAgICAgdmFsdWU6IHVpLnZhbHVlLFxuICAgICAgICAgICAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgICAgICAgICAgICByYXdSZXNwb25zZTogcmVzdWx0LnJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNUb29sQ2FsbCkge1xuICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVJlbmRlcihbeyBjb250ZW50LCBkb25lOiB0cnVlIH1dLCB0ZXh0UmVuZGVyLCB1aSwgdHJ1ZSk7XG4gICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBEdXJpbmcgdGhlIHN0cmVhbSByZW5kZXJpbmcsIHdlIGRvbid0IHdhbnQgdG8gdGhyb3cgdGhlIGVycm9yIHRvIHRoZVxuICAgICAgLy8gcGFyZW50IHNjb3BlIGJ1dCBvbmx5IGxldCB0aGUgUmVhY3QncyBlcnJvciBib3VuZGFyeSB0byBjYXRjaCBpdC5cbiAgICAgIHVpLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgc3RyZWFtLFxuICAgIHZhbHVlOiB1aS52YWx1ZSxcbiAgfTtcbn1cbiIsIi8vIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgQUkgY29udGV4dCB0byBhbGwgQUkgQWN0aW9ucyB2aWEgQXN5bmNMb2NhbFN0b3JhZ2UuXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEludGVybmFsQUlQcm92aWRlciB9IGZyb20gJy4vcnNjLXNoYXJlZC5tanMnO1xuaW1wb3J0IHtcbiAgd2l0aEFJU3RhdGUsXG4gIGdldEFJU3RhdGVEZWx0YVByb21pc2UsXG4gIHNlYWxNdXRhYmxlQUlTdGF0ZSxcbn0gZnJvbSAnLi9haS1zdGF0ZSc7XG5pbXBvcnQgdHlwZSB7XG4gIFNlcnZlcldyYXBwZWRBY3Rpb25zLFxuICBBSUFjdGlvbixcbiAgQUlBY3Rpb25zLFxuICBBSVByb3ZpZGVyLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgT25TZXRBSVN0YXRlLFxuICBPbkdldFVJU3RhdGUsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5hc3luYyBmdW5jdGlvbiBpbm5lckFjdGlvbjxUPihcbiAge1xuICAgIGFjdGlvbixcbiAgICBvcHRpb25zLFxuICB9OiB7IGFjdGlvbjogQUlBY3Rpb247IG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zIH0sXG4gIHN0YXRlOiBULFxuICAuLi5hcmdzOiB1bmtub3duW11cbikge1xuICAndXNlIHNlcnZlcic7XG4gIHJldHVybiBhd2FpdCB3aXRoQUlTdGF0ZShcbiAgICB7XG4gICAgICBzdGF0ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24oLi4uYXJncyk7XG4gICAgICBzZWFsTXV0YWJsZUFJU3RhdGUoKTtcbiAgICAgIHJldHVybiBbZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpIGFzIFByb21pc2U8VD4sIHJlc3VsdF07XG4gICAgfSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gd3JhcEFjdGlvbjxUID0gdW5rbm93bj4oXG4gIGFjdGlvbjogQUlBY3Rpb24sXG4gIG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuKSB7XG4gIHJldHVybiBpbm5lckFjdGlvbi5iaW5kKG51bGwsIHsgYWN0aW9uLCBvcHRpb25zIH0pIGFzIEFJQWN0aW9uPFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQUk8XG4gIEFJU3RhdGUgPSBhbnksXG4gIFVJU3RhdGUgPSBhbnksXG4gIEFjdGlvbnMgZXh0ZW5kcyBBSUFjdGlvbnMgPSB7fSxcbj4oe1xuICBhY3Rpb25zLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbFVJU3RhdGUsXG5cbiAgb25TZXRBSVN0YXRlLFxuICBvbkdldFVJU3RhdGUsXG59OiB7XG4gIGFjdGlvbnM6IEFjdGlvbnM7XG4gIGluaXRpYWxBSVN0YXRlPzogQUlTdGF0ZTtcbiAgaW5pdGlhbFVJU3RhdGU/OiBVSVN0YXRlO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgQUkgc3RhdGUgaXMgdXBkYXRlZCBieSBhbiBBY3Rpb24uXG4gICAqIFlvdSBjYW4gdXNlIHRoaXMgdG8gcGVyc2lzdCB0aGUgQUkgc3RhdGUgdG8gYSBkYXRhYmFzZSwgb3IgdG8gc2VuZCBpdCB0byBhXG4gICAqIGxvZ2dpbmcgc2VydmljZS5cbiAgICovXG4gIG9uU2V0QUlTdGF0ZT86IE9uU2V0QUlTdGF0ZTxBSVN0YXRlPjtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJldHJpZXZlIHRoZSBVSSBzdGF0ZSBiYXNlZCBvbiB0aGUgQUkgc3RhdGUuXG4gICAqIEZvciBleGFtcGxlLCB0byByZW5kZXIgdGhlIGluaXRpYWwgVUkgc3RhdGUgYmFzZWQgb24gYSBnaXZlbiBBSSBzdGF0ZSwgb3JcbiAgICogdG8gc3luYyB0aGUgVUkgc3RhdGUgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgYWxyZWFkeSBsb2FkZWQuXG4gICAqXG4gICAqIElmIHJldHVybmluZyBgdW5kZWZpbmVkYCwgdGhlIGNsaWVudCBzaWRlIFVJIHN0YXRlIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBhbm5vdGF0ZWQgd2l0aCB0aGUgYFwidXNlIHNlcnZlclwiYCBkaXJlY3RpdmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiBvbkdldFVJU3RhdGU6IGFzeW5jICgpID0+IHtcbiAgICogICAndXNlIHNlcnZlcic7XG4gICAqXG4gICAqICAgY29uc3QgY3VycmVudEFJU3RhdGUgPSBnZXRBSVN0YXRlKCk7XG4gICAqICAgY29uc3QgZXh0ZXJuYWxBSVN0YXRlID0gYXdhaXQgbG9hZEFJU3RhdGVGcm9tRGF0YWJhc2UoKTtcbiAgICpcbiAgICogICBpZiAoY3VycmVudEFJU3RhdGUgPT09IGV4dGVybmFsQUlTdGF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICpcbiAgICogICAvLyBVcGRhdGUgY3VycmVudCBBSSBzdGF0ZSBhbmQgcmV0dXJuIHRoZSBuZXcgVUkgc3RhdGVcbiAgICogICBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAgICogICBzdGF0ZS5kb25lKGV4dGVybmFsQUlTdGF0ZSlcbiAgICpcbiAgICogICByZXR1cm4gPGRpdj4uLi48L2Rpdj47XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBvbkdldFVJU3RhdGU/OiBPbkdldFVJU3RhdGU8VUlTdGF0ZT47XG59KSB7XG4gIC8vIFdyYXAgYWxsIGFjdGlvbnMgd2l0aCBvdXIgSG9DLlxuICBjb25zdCB3cmFwcGVkQWN0aW9uczogU2VydmVyV3JhcHBlZEFjdGlvbnMgPSB7fTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGFjdGlvbnMpIHtcbiAgICB3cmFwcGVkQWN0aW9uc1tuYW1lXSA9IHdyYXBBY3Rpb24oYWN0aW9uc1tuYW1lXSwge1xuICAgICAgb25TZXRBSVN0YXRlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgd3JhcHBlZFN5bmNVSVN0YXRlID0gb25HZXRVSVN0YXRlXG4gICAgPyB3cmFwQWN0aW9uKG9uR2V0VUlTdGF0ZSwge30pXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgQUk6IEFJUHJvdmlkZXI8QUlTdGF0ZSwgVUlTdGF0ZSwgQWN0aW9ucz4gPSBhc3luYyBwcm9wcyA9PiB7XG4gICAgaWYgKCd1c2VTdGF0ZScgaW4gUmVhY3QpIHtcbiAgICAgIC8vIFRoaXMgZmlsZSBtdXN0IGJlIHJ1bm5pbmcgb24gdGhlIFJlYWN0IFNlcnZlciBsYXllci5cbiAgICAgIC8vIElkZWFsbHkgd2Ugc2hvdWxkIGJlIHVzaW5nIGBpbXBvcnQgXCJzZXJ2ZXItb25seVwiYCBoZXJlIGJ1dCB3ZSBjYW4gaGF2ZSBhXG4gICAgICAvLyBtb3JlIGN1c3RvbWl6ZWQgZXJyb3IgbWVzc2FnZSB3aXRoIHRoaXMgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGlzIGNvbXBvbmVudCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBTZXJ2ZXIgQ29tcG9uZW50cy4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgdWlTdGF0ZSA9IHByb3BzLmluaXRpYWxVSVN0YXRlID8/IGluaXRpYWxVSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlID0gcHJvcHMuaW5pdGlhbEFJU3RhdGUgPz8gaW5pdGlhbEFJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGVEZWx0YSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIGNvbnN0IFtuZXdBSVN0YXRlRGVsdGEsIG5ld1VJU3RhdGVdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlKGFpU3RhdGUpO1xuICAgICAgaWYgKG5ld1VJU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhaVN0YXRlRGVsdGEgPSBuZXdBSVN0YXRlRGVsdGE7XG4gICAgICAgIHVpU3RhdGUgPSBuZXdVSVN0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8SW50ZXJuYWxBSVByb3ZpZGVyXG4gICAgICAgIHdyYXBwZWRBY3Rpb25zPXt3cmFwcGVkQWN0aW9uc31cbiAgICAgICAgd3JhcHBlZFN5bmNVSVN0YXRlPXt3cmFwcGVkU3luY1VJU3RhdGV9XG4gICAgICAgIGluaXRpYWxVSVN0YXRlPXt1aVN0YXRlfVxuICAgICAgICBpbml0aWFsQUlTdGF0ZT17YWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGVQYXRjaD17YWlTdGF0ZURlbHRhfVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICA8L0ludGVybmFsQUlQcm92aWRlcj5cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBBSTtcbn1cbiJdLCJuYW1lcyI6WyJBc3luY0xvY2FsU3RvcmFnZSIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiUiIsImMiLCJuIiwiY2h1bmsiLCJkb25lIiwidmFsdWUiLCJhcHBlbmQiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwibmV4dCIsImNyZWF0ZVN1c3BlbnNlZENodW5rIiwiaW5pdGlhbFZhbHVlIiwicm93IiwiaXNGdW5jdGlvbiIsIngiLCJjb25zdW1lU3RyZWFtIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsImFzeW5jQUlTdGF0ZVN0b3JhZ2UiLCJnZXRBSVN0YXRlU3RvcmVPclRocm93IiwibWVzc2FnZSIsInN0b3JlIiwiZ2V0U3RvcmUiLCJFcnJvciIsIndpdGhBSVN0YXRlIiwic3RhdGUiLCJvcHRpb25zIiwiZm4iLCJydW4iLCJjdXJyZW50U3RhdGUiLCJvcmlnaW5hbFN0YXRlIiwic2VhbGVkIiwiZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSIsIm11dGF0aW9uRGVsdGFQcm9taXNlIiwic2VhbE11dGFibGVBSVN0YXRlIiwiZ2V0QUlTdGF0ZSIsImFyZ3MiLCJsZW5ndGgiLCJrZXkiLCJTdHJpbmciLCJnZXRNdXRhYmxlQUlTdGF0ZSIsIm11dGF0aW9uRGVsdGFSZXNvbHZlIiwiZG9VcGRhdGUiLCJuZXdTdGF0ZSIsIl9hIiwiX2IiLCJvblNldEFJU3RhdGUiLCJjYWxsIiwibXV0YWJsZVN0YXRlIiwiZ2V0IiwidXBkYXRlIiwibmV3QUlTdGF0ZSIsImRvbmVBcmdzIiwiZGVsdGEiLCJkaWZmIiwiem9kVG9Kc29uU2NoZW1hIiwiQVBJQ2FsbEVycm9yIiwiUmV0cnlFcnJvciIsImdldEVycm9yTWVzc2FnZSIsImlzQWJvcnRFcnJvciIsImRlbGF5IiwiZGVsYXlJbk1zIiwic2V0VGltZW91dCIsInJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlJbk1zIiwiYmFja29mZkZhY3RvciIsImYiLCJfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiZXJyb3JzIiwiZXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJuZXdFcnJvcnMiLCJ0cnlOdW1iZXIiLCJyZWFzb24iLCJpc0FQSUNhbGxFcnJvciIsImlzUmV0cnlhYmxlIiwibWltZVR5cGVTaWduYXR1cmVzIiwibWltZVR5cGUiLCJieXRlcyIsImRldGVjdEltYWdlTWltZVR5cGUiLCJpbWFnZSIsImV2ZXJ5IiwiYnl0ZSIsImluZGV4IiwiRG93bmxvYWRFcnJvciIsImRvd25sb2FkIiwidXJsIiwiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsImZldGNoIiwidXJsVGV4dCIsInRvU3RyaW5nIiwicmVzcG9uc2UiLCJvayIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsImhlYWRlcnMiLCJpc0Rvd25sb2FkRXJyb3IiLCJjYXVzZSIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb250ZW50IiwiQXJyYXlCdWZmZXIiLCJJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciIsImNvbnN0cnVjdG9yIiwicm9sZSIsIm5hbWUiLCJpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwidG9KU09OIiwic3RhY2siLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IiwicHJvbXB0IiwibW9kZWxTdXBwb3J0c0ltYWdlVXJscyIsImRvd25sb2FkSW1wbGVtZW50YXRpb24iLCJsYW5ndWFnZU1vZGVsTWVzc2FnZXMiLCJzeXN0ZW0iLCJwdXNoIiwiZG93bmxvYWRlZEltYWdlcyIsIm1lc3NhZ2VzIiwiZG93bmxvYWRJbWFnZXMiLCJwcm9tcHRUeXBlIiwidHlwZSIsInRleHQiLCJtYXAiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSIsIl9leGhhdXN0aXZlQ2hlY2siLCJwYXJ0IiwiX2MiLCJVUkwiLCJkb3dubG9hZGVkSW1hZ2UiLCJwcm90b2NvbCIsImhlYWRlciIsImJhc2U2NENvbnRlbnQiLCJzcGxpdCIsIl9pZ25vcmVkIiwiaW1hZ2VVaW50OCIsImZpbHRlciIsInVybHMiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0Iiwic3RhcnRzV2l0aCIsImFsbCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiSW52YWxpZFByb21wdEVycm9yIiwiZ2V0VmFsaWRhdGVkUHJvbXB0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJwcmVwYXJlQ2FsbFNldHRpbmdzIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJ0b3BQIiwicHJlc2VuY2VQZW5hbHR5IiwiZnJlcXVlbmN5UGVuYWx0eSIsInN0b3BTZXF1ZW5jZXMiLCJzZWVkIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicGFyYW1ldGVyIiwiY2FsY3VsYXRlQ29tcGxldGlvblRva2VuVXNhZ2UiLCJ1c2FnZSIsInByb21wdFRva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJ0b3RhbFRva2VucyIsInZhbGlkYXRvclN5bWJvbCIsInNjaGVtYVN5bWJvbCIsIlN5bWJvbCIsImpzb25TY2hlbWEiLCJ2YWxpZGF0ZSIsIl90eXBlIiwiaXNTY2hlbWEiLCJhc1NjaGVtYSIsInNjaGVtYSIsInpvZFNjaGVtYSIsInJlc3VsdCIsInNhZmVQYXJzZSIsInN1Y2Nlc3MiLCJpc05vbkVtcHR5T2JqZWN0Iiwib2JqZWN0Iiwia2V5cyIsInByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UiLCJ0b29scyIsInRvb2xDaG9pY2UiLCJlbnRyaWVzIiwidG9vbCIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsInRvb2xOYW1lIiwiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiVGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwidGVybWluYXRlIiwicGFyc2VkTWVzc2FnZSIsImVucXVldWUiLCJ0cmFuc2Zvcm0iLCJmZWVkIiwiZGVjb2RlIiwiY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIiLCJjYiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJhZ2dyZWdhdGVkUmVzcG9uc2UiLCJjYWxsYmFja3MiLCJvblN0YXJ0IiwiZW5jb2RlIiwib25Ub2tlbiIsIm9uVGV4dCIsImZsdXNoIiwiaXNPcGVuQUlDYWxsYmFja3MiLCJpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyIsIm9uQ29tcGxldGlvbiIsIm9uRmluYWwiLCJ0cmltU3RhcnRPZlN0cmVhbUhlbHBlciIsImlzU3RyZWFtU3RhcnQiLCJ0cmltU3RhcnQiLCJBSVN0cmVhbSIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsImNhbmNlbCIsInJldHVybiIsImZvcm1hdFN0cmVhbVBhcnQiLCJjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIiLCJlbmNvZGVyIiwiZGVjb2RlciIsImNyZWF0ZUNodW5rRGVjb2RlciIsInBhcnNlT3BlbkFJU3RyZWFtIiwiZXh0cmFjdCIsImNodW5rVG9UZXh0IiwiSlNPTiIsInBhcnNlIiwic3RyZWFtYWJsZSIsImlkIiwiY3JlYXRlZCIsImdldERhdGUiLCJtb2RlbCIsImNob2ljZXMiLCJjaG9pY2UiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImZ1bmN0aW9uX2NhbGwiLCJmdW5jdGlvbkNhbGwiLCJ0b29sX2NhbGxzIiwidG9vbENhbGxzIiwidG9vbENhbGwiLCJmdW5jdGlvbiIsImZpbmlzaF9yZWFzb24iLCJmaW5pc2hSZWFzb24iLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfaCIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiYXJndW1lbnRzIiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImlzRmlyc3RDaHVuayIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJjb25zb2xlIiwid2FybiIsImFyZ3VtZW50c1BheWxvYWQiLCJzdHJpbmdpZnkiLCJmdW5jIiwicmVzcG9uc2VJbmRleCIsInRvb2xfY2FsbF9pZCIsImZ1bmN0aW9uX25hbWUiLCJ0b29sX2NhbGxfcmVzdWx0IiwidGMiLCJlIiwiZmlsdGVyZWRDYWxsYmFja3MiLCJvcGVuQUlTdHJlYW0iLCJTVFJFQU1BQkxFX1ZBTFVFX1RZUEUiLCJmb3IiLCJERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSIsImNyZWF0ZVN0cmVhbWFibGVVSSIsImN1cnJlbnRWYWx1ZSIsImNsb3NlZCIsImFzc2VydFN0cmVhbSIsIm1ldGhvZCIsIndhcm5pbmdUaW1lb3V0Iiwid2FyblVuY2xvc2VkU3RyZWFtIiwicHJvY2VzcyIsImNsZWFyVGltZW91dCIsInJlc29sdmFibGUiLCJTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0siLCJjcmVhdGVTdHJlYW1hYmxlVmFsdWUiLCJpc1JlYWRhYmxlU3RyZWFtIiwibG9ja2VkIiwiY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbCIsInN0cmVhbWFibGVWYWx1ZSIsImN1cnJlbnRFcnJvciIsImN1cnJlbnRQcm9taXNlIiwiY3VycmVudFBhdGNoVmFsdWUiLCJjcmVhdGVXcmFwcGVkIiwiaW5pdGlhbENodW5rIiwiaW5pdCIsImN1cnIiLCJ1cGRhdGVWYWx1ZVN0YXRlcyIsInNsaWNlIiwicmVzb2x2ZVByZXZpb3VzIiwicmVuZGVyIiwidWkiLCJpbml0aWFsIiwiZnVuY3Rpb25zIiwiZmluaXNoZWQiLCJoYW5kbGVSZW5kZXIiLCJyZW5kZXJlciIsInRoZW4iLCJub2RlIiwiaXRlcmF0b3IiLCJoYXNGdW5jdGlvbiIsInByb3ZpZGVyIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwiZnVuY3Rpb25DYWxsUGF5bG9hZCIsInRvb2xDYWxsUGF5bG9hZCIsIkludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJOb1N1Y2hUb29sRXJyb3IiLCJzYWZlUGFyc2VKU09OIiwiZGVmYXVsdFRleHRSZW5kZXJlciIsInN0cmVhbVVJIiwiYWJvcnRTaWduYWwiLCJvbkZpbmlzaCIsInNldHRpbmdzIiwidGV4dFJlbmRlciIsImxhc3RDYWxsIiwicmV0cnkiLCJ2YWxpZGF0ZWRQcm9tcHQiLCJkb1N0cmVhbSIsIm1vZGUiLCJpbnB1dEZvcm1hdCIsInN1cHBvcnRzSW1hZ2VVcmxzIiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJ0ZXh0RGVsdGEiLCJhdmFpbGFibGVUb29scyIsInBhcnNlUmVzdWx0IiwidG9vbEFyZ3MiLCJ0b29sQ2FsbElkIiwiZ2VuZXJhdGUiLCJ3YXJuaW5ncyIsInJhd1Jlc3BvbnNlIiwiUmVhY3QiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJpbm5lckFjdGlvbiIsImFjdGlvbiIsIndyYXBBY3Rpb24iLCJiaW5kIiwiY3JlYXRlQUkiLCJhY3Rpb25zIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsVUlTdGF0ZSIsIm9uR2V0VUlTdGF0ZSIsIndyYXBwZWRBY3Rpb25zIiwid3JhcHBlZFN5bmNVSVN0YXRlIiwiQUkiLCJwcm9wcyIsInVpU3RhdGUiLCJhaVN0YXRlIiwiYWlTdGF0ZURlbHRhIiwibmV3QUlTdGF0ZURlbHRhIiwibmV3VUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(action-browser)/./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1/node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(action-browser)/./node_modules/.pnpm/next@14.2.26_@opentelemetry_aba728d3d9cad26a5823654e85ed8ba3/node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");


const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\MichaelSanders\Documents\Forklift-Assistant\sample-apps\pinecone-assistant\node_modules\.pnpm\ai@3.2.43_react@18.0.0_sswr_dd5167c5a98091ee23b9cc60ee7b27a1\node_modules\ai\rsc\dist\rsc-shared.mjs#useUIState`);


/***/ })

};
;